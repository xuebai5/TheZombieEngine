/**
    @page ZombieConjurer Conjurer

    @section ZombieConjurerOverview Conjurer Overview

    Conjurer is the game editing tool used in Tragnarion to develop the
    Renaissance game framework with the nebula2-based Zombie engine. This tool
    is used by different kinds of users, either artists, designers or
    programmers.
    It is used to edit, import, modify and test the levels in Renaissance. It is
    possible that Conjurer will be used for other games too.

    @section ZombieConjurerDocumentation Documentation

    - @ref ZombieConjurerManual. How to use the editor.
    - @ref ZombieConjurerWorkingCopy. Where the editor data lives.
*/

/**
    @page ZombieConjurerManual Conjurer User Manual

    This is the Conjurer Editor User Manual.

    Conjurer is divided in two components:

    - Summoner (InGUI): Window which displays the scene and allows the user to
    edit it (that is, the old Conjurer, but without the GUI widgets).
    - Conjurer (OutGUI): External Multi Document Interface (MDI) main window,
    based on the Python language, which now contains all the widgets.

    The main advantage of this approach is that it will let us have a
    multimonitor application. Also the number of controls and libraries of this
    system will help us a lot for its efficiency and rapid development.

    @ref ZombieConjurerUsage

    - @ref ZombieWorkingCopy. Managing the game data repository.
    - @ref ConjurerApplication. How to start the application, command-line
    options, etc.
    - @ref ConjurerSummoner. General info on the Summoner part (INGUI) and keys.
    - @ref ConjurerConjurer. General info on the Conjurer part (OUTGUI) and
    keys.
    - @ref ConjurerNavigation. Camera navigation.
    - @ref ConjurerExit. Quit application.
    - @ref ConjurerConcepts. Main concepts, entity classes, entity objects and
    naming rules.

    @ref ZombieConjurerTopics

    - @ref ConjurerTerrain. Terrain geometry and texture editing.
    - @ref ConjurerObjectTools. Object placing and editing.
    - @ref ConjurerObjectInspector.
    - @ref ConjurerObjectBrowser.
    - @ref ConjurerEntityBrowser
    - @ref ConjurerSelectedEntityTracker.
    - @ref ConjurerLevelManagement.
    - @ref ConjurerCamera.
    - @ref ConjurerLightEditor
      - @ref ConjurerLightEditorTutorial.
    - @ref ConjurerGeometryStream.
      - @ref ConjurerGeometryStreamEditor.
    - @ref ConjurerLoadingAreas.
    - @ref ConjurerVariables.
    - @ref ConjurerBatches
    - @ref ConjurerUndo. Undo system.
    - @ref ConjurerLayers. Layer Manager.
    - @ref ConjurerExportEntity
    - @ref ConjurerPreferences.
    - @ref ConjurerViewports. Viewport management.
    - @ref ConjurerDebugOptions.
    - @ref ConjurerLevels.
    - @ref ConjurerParticleSystem.
    - @ref ConjurerWindow. Window menu.
    - @ref ConjurerHelp. Help system.
    - @ref ConjurerFSMEditor. Create agent behaviours.
    - @ref ConjurerFSMAttacher. Assign behaviours to agents.
    - @ref ConjurerTriggers. Create triggers.
    - @ref ConjurerAITestMode. Test triggers and agents.
    - @ref ConjurerCharacterEditor. Adjusting animations and setting
    attachments.
    - @ref ConjurerSoundEditor. Editing sound library and event tables.
    - @ref ConjurerSoundSources. Placing and testing sound sources in the level.
    - @ref ConjurerPresets. Level presets management.
    - @ref ConjurerCommandManager. Creating custom classes and commands.
    - @ref ConjurerAreaEvents. Concept behind area events.
    - @ref ConjurerNavigationMesh. Navigation mesh building process.
    - @ref ConjurerWaypointTool.
    - @ref ConjurerPreloadManager. How to specify resources to preload for a
    level.

    @ref ZombieConjurerHowto Howtos

    - @ref ConjurerHowToDoorTriggers
    - @ref ConjurerHowToVehicle
    - @ref ConjurerHowToSeaFoam

    @ref ZombieConjurerProgrammers Programmers

    - @ref ConjurerLog. Log inspector.
    - @ref ConjurerSystemInfo.
    - @ref ConjurerScriptEditor.
    - @ref ConjurerScriptManager. Quick access to custom scripts.
    - @ref ConjurerWatcher. Variable and command watcher.
    - @ref ConjurerProfilers. Display and use of hierarchical profilers.
    - @ref ConjurerVariableMonitor. Manager of the InGUI variable graphs.
*/
    
/**
    @page ZombieConjurerUsage Conjurer Usage

    
    @section ConjurerApplication Application

    Command Arguments

    -state [state_name] Start conjurer in the named state, by default "editor"
    -view [n2_script] Open the N2 object autodetecting (entity class, level,
    scene, ...)
    -class [class_name] Open the class with the name specified.
    -level [level_name] Open the level script specified.
    -fullscreen open in full screen mode
    -alwaysontop keep the render window on top of all other windows.
    -x [pixels] initial x position of the window.
    -y [pixels] initial y position of the window.
    -w [pixels] width of the window.
    -h [pixels] height of the window.
    -wc [path] path to working copy.
    -wc2 [path] path to temporary working copy.
    -gui [path] script for the outgui when G is pressed, by default
    code/conjurer/gui/outgui.py
    -embedded option to include the render window as another window inside the
    GUI.
    -sync option to enable vertical sync synchronization
    -startup [script] startup script, by default data/scripts/startup.lua
    -layout [n2_script] viewport layout script, by default
    data/appdata/conjurer/viewport/appviewportui.n2
    -anim [state_name] integer specifying the animation state
    -help shows help about each option
    -projdir [path] sets project directory, not used
    -watch [pattern] specify by default watch variable
    -newinstance [instance_name] create a new named instance of conjurer even if
    another one is already running
    -lockframetime [miliseconds] Lock frame time

    
    @section ConjurerSummoner Summoner

    @subsection ConjurerSummonerGeneralKeys General keys in normal editor state

    C: Toggle show of origin axis
    G: show Conjurer (OUTGUI)
    K: Move light with camera
    L: Set light position at camera position
    M: Toggle show terrain map viewport
    P: Toggle show mouse pointer
    X: Toggle show small axis in left-bottom of viewport
    CURSOR KEYS: move camera
    SPACE: reset camera position to (0, 0)
    F3: Toggle to Cathari mode.
    F7: change animation state
    F8: Toggle ocean
    F9: Toggle skybox
    F11: console
    F12: screenshot
    ALT - E: Toggle edit indoor mode
    ALT - I: Toggle view all indoor mode
    ALT - F: Toggle show FPS
    ALT - G: Toggle editor grid
    ALT - X: Switch to maximize viewport
    ALT - W: Switch single viewport / multiple viewports
    ALT - Enter: Toggle to fullscreen mode
    CTRL - Z: Undo
    CTRL - C: Copy selection
    CTRL - X: Cut selection
    CTRL - Y: Redo
    CTRL - Z: Paste selection
    DEL: Delete selection

    @subsection ConjurerSummonerBookmarks Bookmarks

    ALT + 0: Bookmark current position, or delete bookmark if we're at one
    ALT + 1..9: Go to bookmark#

    @subsection ConjurerSummonerView View

    F6: Toggle perspective / orthogonal view
    control - T: Top view
    control - F: Front view
    control - K: Back view
    control - R: Right view
    control - L: Left view
    Object state shortcuts
    E: Select entity selection tool
    R: Select rotation tool
    T: Select traslation tool
    Y: Select scale tool
    CTRL - SPACE: Toggle lock mode of transform tools.

    @subsection ConjurerSummonerDebug Debug

    0: Toggle wireframe mode
    1: Toggle diffuse map
    2: Toggle bumpmap
    3: Toggle lightmap
    4: Toggle diffuse light
    5: Toggle specular light
    6: Toggle terrain lod
    8: Toggle skeleton
    B: Toggle draw bounding boxes
    F: Toggle physics
    I: Toggle visibility information
    N: Toggle draw portals
    V: Toggle visibility

    @subsection ConjurerSummonerWanderingMode Wandering Mode

    W: Move forward
    A: Left Strafe
    D: Right Strafe
    S: Move backwards
    Q: Rotation Move to the left
    E: Rotation Move to the right
    Mouse Right Button: Camera close up.
    Mouse Left Button: Camera away.
    Mouse Lateral Movement: Rotation Move.
    Mouse Forward/Backward Movement: Changes Camera High.

    
    @section ConjurerConjurer Conjurer

    @subsection ConjurerConjurerUserSettings User Settings

    You can customize some Conjurer attributes through the Preferences dialog or
    through some other more specialized dialog (like the Script Manager).

    Also, when exiting Conjurer all opened windows are persisted. Then the next
    time you start up Conjurer it's restored to the same state as you left it,
    except for some minor attributes (for instance, the scroll position in a
    script editor).

    @subsection ConjurerConjurerConstraints Constraints

    Some numeric input boxes are constrained within a value range. For these, it
    isn't allowed to enter an invalid or out of range number at any moment. For
    instance, numeric input boxes attached to sliders have the same valid value
    range as their slider. Then, if the slider has a minimum value of 10, you
    are not allowed to enter in the numeric input box any value lower than 10 at
    any moment. This constrainment is forced to assure consistence in scene and
    entities attributes, but sometimes it can be annoying. For instance, in the
    previous example trying to enter a 20 can be tedious since entering the
    first digit by replacing the old value will be rejected since the control
    doesn't allow to have a value lower than 10 at any moment (and 2, the first
    digit of 20, is lower than 10).

    @subsection ConjurerConjurerShortcuts Shortcuts

    All shortcuts are shown at the right of its menu option. Current shortcuts:

    - Ctrl+Q: Quit Conjurer, but not Summoner.
    - Ctrl+Z: Undo last done operation.
    - Ctrl+Y: Redo last undone operation.
    - Alt+W: Toggle Summoner single/multiple viewports.
    - Ctrl+O: Open an object browser.
    - Ctrl+G: Open griomire.
    - Ctrl+E: Open an entity browser.
    - Ctrl+P: Open an object inspector for the selected entities.
    - Ctrl+T: Open an inspector that tracks the entities currently selected in
    Summoner

    
    @section ConjurerNavigation Navigation

    @subsection ConjurerNavigationFreeCam Free camera mode

    If CTRL, SHIFT or ALT are pressed the camera does not move.
    - W-S-A-D keyset to move forward, backward, strafe left/right
    - Keypad 7 and 1 to strafe up/down
    - Right Mouse Button pressed and mouse move for look. (Also cursor keys)
    - Center Mouse Button pressed and mouse move for strafe left/right or move
    up/down
    - Mouse Wheel for zoom
    - Keypad + / - for camera speed control

    @subsection ConjurerNavigationGameCam Game camera mode

    In Game Camera Mode the movement is the same as in free camera mode.
    However, the camera cannot pass through objects and the height of the camera
    remains the same unless it collides with the physical floor. This means that
    the camera will go up stairs automatically.

    
    @section ConjurerExit Conjurer Exit

    @par Quit options

    - Conjurer File/Quit Conjurer menu option: Persist and close Conjurer, but
    don't close Summoner.
    - Conjurer File/Quit Application menu option: Persist and close Conjurer and
    Summoner.
    - Conjurer window close button: Same as File/Quit Conjurer menu option.
    - Summoner window close button: Same as File/Quit Application menu option.

    
    @section ConjurerConcepts Editor Concepts

    @subsection ConjurerConceptsEntityType Entity Type

    Entity types are created by programmers. They provide specific functionality
    and data fields (properties). They are generic things and don't have
    content. Examples of entity types are:

    - neCharacter representing a generic skinned character.
    - neBrush representing a graphical brush (with collision and physics).
    - neIndoor representing a generic indoor.
    - neVehicle representing a generic vehicle.
    - neWeapon representing a generic weapon.
    - neWeaponAddon representing a generic weapon addon.

    And many more ...

    @subsection ConjurerConceptsEntityClass Entity Class

    Entity classes:

    - Are created by artists.
    - Are generated by the 3D Studio MAX Exporter.
    - Have a name to identify them. There are naming rules (see below).
    - Have an asset. The asset includes graphical materials, meshes, collision
    geometries, textures, etc.
    - Have an entity type.
    - Are global to all levels.
    - Examples: Palmtree, Lemontree, Bunker_island1, Alien, Handgun, ...

    However, it is also possible to create entity classes in the editor:

    - Created by designers.
    - Created in the Conjurer tool.
    - Have a name to identify them. See naming rules below.
    - Do not have an asset directly, but use an asset from another class that
    has already been exported by the artists.
    - Have a parent class (the asset is inherited from the parent class).
    - Inherit property values from their parent class, but values can be
    modified.
    - Examples: Alien_lazy, Alien_rude, Alien_paranoid.

    Now that you are familiar with entity classes, we can tell you that entity
    types are really entity classes too, a native entity class, which becomes
    the root of user-created entity classes.

    @subsection ConjurerConceptsEntityClassNamingRules Naming Rules for Entity
    Classes

    The names of entity classes:

    - Must start with an uppercase letter (normally tools automatically
    capitalize the first letter).
    - Allow numbers, lowercase letters or underscores for the remaining
    characters.

    Examples of valid names: Palmtree, Ak47, Car_small

    Examples of invalid names: palmtree, AK47, PalmTree, 1Car, _Palmtree

    @subsection ConjurerConceptsEntityObjects Entity Objects

    - Represent a real object placed in a level.
    - Created by designers, artists.
    - Placed in a level with the Conjurer tool.
    - Have an identifier (e.g. 0x1033221A).
    - Instances are from an specific entity class.
    - Share properties from their entity class.
    - Have object properties.
    - May have a name for easier identification.
    - Entity objects are in a specific level.

    @subsection ConjurerConceptsOther Other types of objects

    These are not so important, but listed here for completeness:

    - nRoots. This are accessible through the object browser. They are organized
    hierarchically like a file system with directories. This organization is
    called NOH (Nebula Object Hierarchy).
    - nObjects. Not very common, they are not in the NOH. Normally obtained
    through other objects.
*/

    
/**
    @page ZombieConjurerTopics Conjurer Topics

    @section ConjurerTerrain Terrain

    @subsection ConjurerTerrainCreating Creating a terrain

    WARNING: A terrain can be shared by several levels, but it's not a good idea
    to use this feature if the terrain geometry is going to be further modified,
    particularly when other objects depend on the terrain layout. So, in most
    cases it is safer to create a new terrain class for each level (see below).

    Some concepts:

    - A level can only have a single terrain.
    - Terrain geometry and material is actually stored in a terrain class.
    - A level doesn't have a terrain class, but a reference to a terrain class
    (so two levels share the same terrain if they
    have a reference to the same terrain class).

    Steps to add a terrain to a level:

    1. Create a new terrain class with the Terrain/New class... menu option.
    2. Add a reference to the terrain class you want for this level, with the
    Terrain/New terrain... menu option (or by enabling Create a terrain in the
    new terrain class dialog). This option is disabled when the level already
    has a terrain.

    [image: new_terrain.jpg]

    New terrain class dialog fields:

    - Class name: Name of the terrain class. The name must be unique,
    capitalized (first letter uppercase, others lowercase) and without spaces or
    any special characters (just letters, numbers and underscore). If you enter
    a bad name the dialog will complain when you press the OK button (be
    careful, as three warnings means a red card and you miss next Wednesday's
    soccer match).
    - Point separation: Distance between each point, in metres.
    - Terrain size: Size of the terrain, in pixels (equivalent distance in
    metres is also shown).
    - Block size: Size of each block, in pixels (equivalent distance in metres
    is also shown).
    - Level size: Size of the level, in metres.
    - Minimum height: Minimum allowed height for any point in the terrain.
    - Maximum height: Maximum allowed height for any point in the terrain.
    - Flatten all at: Set all initial points to the same height.
    - Weightmap resolution: Resolution of fine-level mix (weightmap) texture.
    - Global texture resolution: Resolution of coarse-level color texture.
    - Cells per terrain block: The number of cells per terrain block.
    - Editor map resolution: The map resolution to apply when editing
    vegetation.
    - Create a terrain: Automatically add a reference to this new terrain class
    to the level. This option is disabled if the level already has a terrain.

    @subsection ConjurerTerrainEditor Terrain editor

    The terrain editor dialog has three parts:

    - Paintbrush selection
    - Tool selection
    - Tool properties

    To edit the terrain, you select a paintbrush, then select a tool, change the
    tool properties as needed and then apply the tool directly in the Summoner
    window.

    @par Paintbrush selection

    Paintbrushes are the mask you use to edit the terrain. All paintbrushes can
    be used with every tool that needs one, and you select a paintbrush by
    clicking its icon. There are predefined paintbrushes, wich you can resize
    with the slider under the icons. You can also add your own paintbrushes,
    wich will have a fixed size. To add paintbrushes, simply add them as bmp
    images in the appdata\conjurer\terrain\paintbrushes nebula folder. The
    images should be square and 32 bpp. Only the red channel is used to make up
    the paintbrush. Limitation: user defined paintbrushes must have a power of 2
    size.

    @par Tool selection

    There is a combo list where you can select one of the tools. The tools are
    explained below
    - Raise/low: Raise or low the terrain. Use 'Alt' key to lower.
    - Flatten: Make the terrain flat and move to the selected height, or to the
    terrain height under the mouse pointer if the adaptive checkbox is set.
    - Slope: Change the terrain to have the selected slope.
    - Noise: Change the terrain randomly with a noise function.
    - Smooth: Smooth the terrain.
    - Paint: Paint textures on the terrain. This tool is used with the terrain
    layers dialog.
    - Hole: Draw holes on the terrain. (This tool is not complete)

    @par Tool properties

    There are properties common to every tool, such as the intensity. Other
    properties depend on the tool and are explained below. Some tools don't need
    any parameters, such as the hole tool.

    Properties of each tool

    - Raise/low: Only has intensity.
    - Flatten: Target height (the terrain tends to that height). Checkbox and
    adaptative intensity: Makes the target height
    adapt to the height under the mouse pointer as it moves.
    - Slope: The target slope angle (degrees)
    - Noise: Only has intensity
    - Smooth: Only has intensity
    - Paint: Has intensity (meaning the amount of paint you apply while
    painting), and blend intensity, which means the opacity of the paint. Also
    it has two filters, by height and by slope. Activate each filter with the
    checkbox and select the min and max values for each filter. Areas with
    height or slope values over the range will not be painted. The two filters
    can be activated independently. Note that the terrain painting has a limit
    of 5 layers at once in each block (the block size is specified when the
    terrain is created).

    You can have lots of terrain layers but in a particular block there can be
    only 5 of them, the rest are ignored. So when you paint with a layer it may
    appear in a special color ( pink), meaning that the layer will be ignored.
    When you continue painting with that layer, it eventually becomes the 5th
    most used layer, so it now appears with its texture, and the layer
    that was the 5th one is now ignored and is shown in the special colour.
    - Hole: No parameters.

    Attenuation

    Most terrain tools have attenuation and intensity fields. The intensity
    field represents the strength of a tool when it's used on the terrain. A
    terrain may be edited at very different detail levels, from leveling whole
    mountains to doing small detail adjustments. In the first case, large
    intensity values are used, while in the second case small ones are used. The
    problem is that this gives a small usable intensity range to work with each
    case. To 'enlarge' this range, you can use the attenuation.

    The attenuation modifies the intensity by reducing its value. So for greater
    attenuation values, you need to set a greater intensity value to achieve the
    same intensity strength as with a smaller attenuation. That is, the same
    intensity is less strong with an attenuation of 2 than with an attenuation
    of 1. Keep in mind that intensities of 0 and 1 aren't affected by the
    attenuation, since the intensity is an exponential function that goes from 0
    to 1, and the attenuation is its exponential factor.

    [image: terrain_attenuation.jpg]
    
    @section ConjurerObjectTools Object Tools

    @subsection ConjurerObjectToolsIntro Introduction

    The object tools are on the upper tool bar. They are:

    - Selection tool
    - Translation tool
    - Rotation tool
    - Scaling tool
    - Placing tool
    - Multiple placing tool
    - (Terrain mode button)
    - Waypoint tool
    - Circle area trigger tool
    - Polygon area trigger tool
    - Rule tool
    - World/local mode button
    - Terrain collision combo
    - Selection mode combo
    - Lock selection button

    Additionally, objects can be copied, pasted and inspected.

    @subsection ConjurerObjectToolsExplanation Tool explanation

    @par Selection tool

    Select objects by clicking on them, or drag a rectangle to select multiple
    objects. Pressing the control key while clicking adds objects to the
    selection, while pressing alt removes them.

    @par Translation tool

    Select the objects to move. When you select this tool, three axes appear in
    the middle of the selection. Click on an axis arrow or a square of the axis
    reference to move the selection along that axis or plane.

    @par Rotation tool

    Click on an axis reference arrow to rotate the selection around that axis.

    @par Scaling tool

    Click on an axis or a square of the reference axis to scale the selection.

    @par Placing tool

    Select a entity class in the Grimoire and you can click where you want the
    object, it will appear glued to the surface you click. If you click in the
    air the object will appear at some distance instead. You can move the mouse
    and select the position until you release the left button.

    @par Multiple Placing tool

    This works in a similar way to the terrain tools and works only when there
    is a terrain. Basically the tool places objects with a brush over the
    terrain. The option 'Multiplace object settings' in the tool menu opens a
    dialog where you can set the brush diameter (in meters) and the density.
    There is also an option to give random rotation to the placed objects.

    @par Waypoint tool

    You can create waypoint entities with this tool, similarly to how you create
    entities with the placer tool. The waypoints created are global: switch to
    waypoint selection mode to create a waypoint associated with a brush or
    indoor (look ahead).

    Waypoints are linked to create paths automatically: when you create a
    waypoint, all selected waypoints are linked to it. Also, the last created
    waypoint becomes the selected one, so you can create a linear path just by
    placing waypoints. To link waypoints without creating a new one, press
    control while you click on a waypoint: all selected waypoints will be linked
    to it.

    @par Circle area trigger tool

    Use this to place a circular area trigger. After placing one you can open an
    object inspector window on it and change its properties.

    @par Polygon area trigger tool

    This is similar to the circle area tool, with the addition that you start
    placing points to define the polygon shape, and when you're finished press
    the escape key.

    @par Rule tool

    This is used to measure distances across the terrain. The Tool Info window
    shows the direct distance and the distance over the terrain, as well as the
    slope of the terrain at the cursor.

    @par World/local mode button

    This button sets world or local mode. In world mode the translation or
    rotation is always done with respect to the world axis, while in local mode
    it is done with respect to the object axis.

    @par Terrain collision combo

    This combo list allows you to choose the terrain collision mode when you
    move objects. There are three modes: no collision, collision and snap to
    terrain.

    @par Selection mode combo

    The second combo list sets the selection mode, currently only object
    (normal) mode and subentity edit mode are available.

    - Normal mode: You select and edit general entities.
    - Subentity mode: You can select an entity that has 'superentity
    capabilities' and then select this mode. Then you can create entities
    attached to this superentity, that is shown in blue. Note that this is a
    class-level property, every entity of that class that you create will
    automatically have those subentities created. In this subentity mode you
    can't select or edit other entities or their waypoints. When you've finished
    editing the subentities of that superentity class, select normal mode again
    and a pop-up window will ask you if you want to save or discard your
    changes.

    @par Lock selection button

    The 'lock' button toggles the transform tools from 'select and transform' to
    'only transform' mode, but you can use the whole window to define the
    transform. That is, you can click with the pointer anywhere on the screen,
    you don't have to pick the axis you want every time (the last axis chosen is
    remembered)

    @par Snap

    The translation, rotation and scaling tools can be used with a snap option,
    which can be enabled from the View menu:

    - Snap to grid: Makes the objects moved by the translation tool snap to the
    grid.
    - Angle snap: The rotation tool will rotate an object in fixed angle
    increments.
    - Size snap: The scaling tool will scale an object in fixed scale factor
    increments.

    Snap properties can be changed in the preferences (menu option
    Edit/Preferences).

    @par Copy-paste and inspection

    There's support for copy, cut, paste and delete operations on selected
    objects. These operations can be applied through the Edit menu or the
    standard shortcuts.

    Also, selected objects can be inspected, for review or edit, by the
    Edit/Selected entities menu option, which opens an object inspector for all
    selected entities. If you don't want to fill up the editor with so many
    windows, you can open a special object inspector that will refresh each time
    you select a new object by inspecting that last selected object. This
    special object inspector can be opened through the Edit/Track selected
    entity menu option (but bear in mind that you need to have at least one
    entity selected when you invoke it).
    
    @section ConjurerObjectInspector Object Inspector

    Overview

    The object inspector allows you to view and to change an object's state. The
    object inspector displays three general panels for all objects, while for
    some objects specialized panels are shown too. The aim of these specialized
    panels is to allow the user to change the object's state in a more intuitive
    way. There are three general panels:
    - Properties: Allows the user to change the published properties of an
    object. It provides help, sliders, etc. It is a much more user-friendly
    editor than the state editor.
    - State: Allows the user to set the state of the object being inspected.
    This is the old version of the property editor. Not as easy-to use as the
    new one and provides less functionality.
    - Command: Allows the user to execute commands implemented by the object
    being inspected.
    - Signals: Allows the user to make the object being inspected fire some of
    its signals.
    The object inspector cannot be opened directly (there's no menu option or
    similar that will allow you to specifically open an object inspector): it's
    always opened by some option/operation that implies inspecting an object
    (for instance, editing the standard light).

    Property editor

    The property editor can be used to edit different kinds of objects: check
    @ref ConjurerConcepts for a description of each type of object such as
    entity classes, entity objects, etc.

    Values modified in the property editor are changed immediately. There are
    three buttons at the bottom of the dialog:

    - OK: Press OK if you are happy with the values you have changed in the
    property editor. This closes the property editor.
    - Revert: Use Revert when you want to discard all changes made in the
    property editor and restore the original values. This does not close the
    property editor.
    - Cancel: Use Cancel when you want to discard all changes made in the
    property editor. This closes the property editor.

    In the top part of the property editor there is a radio button with three
    possible values. These are only available for entity classes:

    - Normal. All values changed are changed for this object only.
    - Cascade. All values changed are propagated to child classes (not only one
    level down, so this includes grandchildren, etc.). However, values in child
    classes are only changed if they have the same value as the edited entity
    class.
    - Force. All values changed are propagated to the child classes whether they
    have the same value or not.

    This is an example of a property editor window. You can see the slider, flag
    properties, etc.

    [image: property editor]
    
    @section ConjurerObjectBrowser Object Browser

    This a NOH (Nebula Object Hierarchy) browser. It can be used to browse any
    of the Nebula objects. The browser has three parts:

    - Tree browser
    - Search system
    - Status bar

    Tree browser

    This is the browser itself. All nebula objects are shown in this tree view.
    You can expand or collapse the elements to navigate through them. When an
    object is selected, you can open an inspector on this object. You can open
    the inspector by double clicking with the mouse over the object name or by
    pressing the open button. You can set the current object to the current work
    object by pressing the Set Cwd button. If you press F1 when an object is
    selected and has focus, the help system will show the doxygen class
    documentation for the object.

    Search system

    You can search in three diferent ways:

    - By object name: This looks for a match by object name only and ignores the
    path.
    - By class name: This looks for a match by object class name.
    - By path: This looks for a match on the entire object path.

    Status bar

    The class name of the currently selected object is shown on the left, and
    the number of matches in the last search is shown on the right.
    
    @section ConjurerEntityBrowser Entity Browser

    The Entity Browser shows a list of all currently-loaded entities.

    [image: entity browser]

    - Move - Move the camera to show the selected entity
    - Rename - Rename the selected entity
    - Reset - Clear the selection
    - Inspector - Inspected the selected entity or entities
    - Import from File - Import entities from file
    - Export to File - Export the selected entity or entities to file. Opens the
    Export Entity Dialog
    - Delete - Delete the selected entity
    - Natives - Allow the user to filter the entities shown by native type (see
    below).
    - Search field - Allow the user to enter search criteria.
    - Active filter checkbox - If 'active filter' is selected the list of
    entities updates dynamically as the user types. If it is
    switched off the user can update the list by pressing enter in the Search
    field or by pressing the Refresh button. By
    default the option is switched off.
    - Refresh - Update the list of entities

    Natives

    Clicking the Natives toolbar button opens the Filter by natives panel.

    [image:  entity_browser_selection]

    By default all native types are shown. To limit the types that are shown
    click the All natives check box to enable the list of natives and then
    select the appropriate types from the list.

    Select the Apply when selecting option to limit selection in Summoner to the
    selected native types. This is useful on levels where there are a large
    number of placed objects and allows the user to focus on those entities in
    which they are most interested: an artist might set the tool to select only
    nebrush and nemirage objects, while a designer could choose to select only
    AI-related objects.

    To close the panel click the Natives toolbar button again, or use the close
    button in the panel itself.
    
    @section ConjurerSelectedEntityTracker Selected Entity Tracker

    The Selected Entity Tracker shows a list of all currently-selected entities.
    N.B. It does not show items selected in the entity browser that cannot be
    selected in Summoner.

    [image: tracker]

    The tracker can be opened with the CTRL + T shortcut combination or from the
    Edit menu.

    The following details are shown for each selected entity:

    - Object id
    - Class name (shown in brackets)

    The Inspect button allows the user to open an object inspector on the given
    entity.
    
    @section ConjurerLevelManagement Level Management

    Overwiew

    Summoner can only work with one level at a time. By default Summoner opens
    on a default level (if no other level is given as command argument). The
    user can do anything he/she wants with this default level except save it, so
    bear in mind that any changes that you make to the default level will be
    lost.

    Operations

    The operations to manage levels can be found in the Level menu:

    - New level: Create a new level. You will be asked for a new level name,
    which must be unique. When creating a new level, a new blank level will be
    created in the working copy and then loaded in Summoner, replacing the
    current one. Further changes to the level must be saved manually.
    - Open level: Load an existing level into Summoner, replacing the current
    one.
    - Save level: Save the level currently loaded in Summoner. This option is
    disabled if working with the default level.
    - Delete level: Delete a level. Neither the currently open level nor the
    default level can be deleted.
    
    @section ConjurerCamera Camera

    Camera editor

    You can quickly access the cameras attached to the viewports through the
    Edit/Cameras submenu.

    If the slider ranges are too broad or too restrictive please let us know,
    since the current values are guesses. Meanwhile you can always set an out-
    of-range value using the State or Command panels.

    [image: camera editor]
    
    @section ConjurerLightEditor Light Editor

    Standard light editor

    You can quickly access the standard light editor from the Edit/Lights
    submenu. The editor is split into light and fog editors, both of which are
    fairly intuitive. Note that when switching to a spot light a new control
    appears at the bottom of the light editor.

    [image: standard light]

    Light Editor

    Conjurer allows the creation, placing, editing and deletion of lights. It
    provides a built-in library of light entity classes that can be used as
    templates to create all kinds of lights supported in Zombie graphic
    materials. Each of these types and the way they work in different
    environments are detailed below.

    Light types

    A light in Conjurer has two different types of behaviour that can be
    combined to render the different light templates: spatial behaviour (related
    to range and visibility) and graphic behaviour (related to rendering and
    shading). The attributes of each are as follows:

    Spatial attributes:

    - range: space (the light reaches all cells in the indoor or outdoor space
    to which it belongs) / cell (the light reaches only within the cell it is
    contained-- roughly, an indoor room)
    - model: Omni all objects within its range are lit / sphere objects within a
    radius are lit / frustum objects within a cone shaped area are lit. Sphere-
    model lights are given a radius, Frustum-model lights are assigned a
    distance and a cone angle, Omni lights have no model attributes.

    Graphic attributes:

    - type: ambient (the light has no spatial position or direction, it lights
    surfaces uniformly) / directional (the light has a direction only) / point
    (the light has a position) / spot (the light has a position and also a
    projection frustum- used mainly to project textures onto lit surfaces)
    - model: additional parameters for the light, dependent on its type-
    point/sphere lights require an inner and outer radius; point/omni lights
    require a light attenuation factor; spot/frustum lights require an inner and
    outer cone angle.
    Note that spatial and graphic behaviour are closely related and the light
    templates have therefore been carefully designed to allow them to work
    together.

    Light templates

    It is important to remember that all of these lights implement light
    behavior only. They need to be combined with some light-emitting surface or
    effect to give the visual appearance of a light source.

    Anyway, all of the lights are provided with an icon that acts as a helper
    and can be enabled or disabled using the debug option: Show Lights.

    - Omnilight: This is a point light with space range and no spatial model.
    When placing the light, define whether it is a cell or space light using the
    AffectsOnlyACell property.
    - Sun: This is a directional light with space range and no spatial model.
    Use it for outdoor environments. Although it has a position, only its
    direction is used in calculations, so you only need to rotate it.
    - Lightbulb: This is point light with a sphere model. You can adjust its
    radius (visibility), and its inner and outer radius (for graphic
    attenuation)
    - Torchlight: This is a cone light with a frustum model. You can adjust its
    angle of view (visibility), and its inner and outer angles (for graphic
    attenuation)

    Fog templates

    Fog: Weird as it may sound, fog is modelled using exactly the same
    attributes and types of behaviour as lights. After all, fog modes can be
    modelled as omni/ambient lights with a different set of attributes. The
    following set of Fog templates have been defined along with lights:
    - Linear fog- This is defined with a distance range (distance from the
    viewer where the fog begins and ends). Fog
    intensity is linearly interpolated within this range.
    - Layered fog- This is defined with a range (maximum fog distance) and top
    value (height of the fog layer).

    Terrain lighting

    Lighting a whole terrain is a resource-consuming task for space-range lights
    (the sun, mainly). dynamic lighting must be done in any case using model-
    shaped (not omni) lights: vehicle lights, torches, etc. that will light only
    within their model.

    But for outdoor lighting, a set of textures can be precomputed for all
    terrain blocks that encapsulate the static light environment from a specific
    light source. This kind of lighting can be used for two purposes:
    prelighting the terrain itself, which saves a lot of dynamic computations;
    and lighting dynamic (moving) entities under the influence of this outdoor
    light: projecting the pre-computed light maps onto the characters, vehicles
    and the rest of moving entities while they move across the terrain.

    This is accomplished using the Generate Lightmaps option in the Terrain
    Editor. This generates a new light class that contains the precomputed
    textures for a terrain and light instance. This way, both the light and the
    terrain can be reused in different levels with a different light mood (dawn,
    midnight, etc.), simply generating a light environment. Please note that
    this light environment is static: you must recompute it again if you edit
    either the terrain or the light.

    These precomputed light environments encode:

    - the lightmap textures for the terrain geometry, with the precomputed
    lighting of terrain blocks, including precomputed shadows of static
    entities. It is similar to the lightmaps generated inside modeling tools
    like 3ds max. These textures are used to modulate the terrain materials.
    - the shadow textures for both the terrain and dynamic entities- These are
    used to project shadows on dynamic geometry moving across the terrain.

    Shadows

    There will be two types of shadowing available in Conjurer: precomputed
    static environments (shadow maps), and dynamic shadow volumes. The former is
    used for static entities such as large outdoor environments, while the
    latter is used for dynamic entities. Shadow textures for the terrain have
    been covered in terrain lighting, this is for shadow volumes.

    Shadow volumes use a shadow geometry that is a simplified version of the
    rvisible one, with the constraint that it must be "closed" (meaning the
    geometry has no holes). Resulting shadows have a sharp appearance. To enable
    a light to cast shadows, use the CastShadows property of lights. Only lights
    with a light model (point, spot) can be shadow casters. For performance
    reasons, the ranges of shadow-casting lights shouldn't overlap, that is, no
    model should cast two or more shadows, except in rare ocasions (eg. lights
    from two different cars crossing).

    To turn a model into a shadow caster, use the IsShadowCaster property of
    regular entities. Remember that shadow geometry is not generated for indoor
    geometry, only for brushes, characters and other entities.

    Enabling/disabling light visibility

    The default operation of Conjurer as a viewer (as used by both artists and
    designers) is to use a single, standard light source, that can be used to
    move with the camera, select different types of light (point, spot) and fog
    (linear, layered). This standard light affects everything that is in the
    current level or scene, using no light ranges or areas. It is an
    allencompassing light that can be used for preview and testing.

    When lights are placed in the editor, this light must be disabled, and
    placed lights must be correctly related to light affected cells and
    geometries. To enable this, use the LIGHTS- enable visibility option in the
    viewport options (or the F10 key). If you use it in a scene or level with no
    lights, the whole scene will turn black (dark) except for surfaces with
    lightmap textures. In this mode, only lights in the level are used, along
    with all of their ranges, areas of influence, shadow-casting features. Go
    back to the single-light mode by disabling this option.

    @todo Pending light features

    - light template for lights projecting arbitrary textures (either light- or
    shadow- maps) using either a 2D or cube texture.
    - mark lights as static (= modulate lightmaps) or dynamic (can be attached
    to moving entities). Also, statics can be used to precompute light
    environments, for both indoors and outdoors.
    
    @subsection ConjurerLightEditorTutorial Light Editor Tutorial

    This tutorial details how to place lights in indoor spaces using Conjurer.

    Introduction

    Unlike dynamic geometry, lights are inherent to every indoor space. Thus,
    instead of adding lights to an indoor space when it is placed in the level
    (which is problematic and not reusable) we'll edit indoor lights using the
    indoor as a superentity. This way, you can edit your indoor lights without
    having to actually load the level to place them. When you place one of these
    indoor objects in the level, the lights are loaded automatically and are
    updated if you edit the lights from outside.

    Step 1: Open The Indoor: Open an instance of the indoor class you want to
    edit. Select it with the selection tool, and select Subentities in the
    editor mode list. It is highly recommended that you select the option
    "Render Bounding Boxes: lights" in the viewport debug window.

    [image: light editor tutorial 1 and 2]
    Fig. 1 Fig. 2

    Step 2: Place The Lights: Locate the room where you want to place the light.
    From the Lights folder in the Grimoire, select the entity class and place it
    in the room. If you use the ALT-E mode (lock visibility) you can move
    outside the cell to edit easily. Place it as near as possible to the light
    source. Enabling the "Render Bounding Boxes- LIGHTS" debug option would be a
    good idea too.

    (lightmapped geometry of the indoor is correct for now)

    [images: light editor tutorial 3 and 4]
    Fig. 3 Fig. 4

    place the light and move it to the room find the room to place the lights in

    Adjust light properties: range and influence Move the light to approximately
    the position of the light source

    Step 3: Set Light Properties: The most important properties you need to set
    to make the light work as expected are:

    - LightStatic, LightDynamic: these identify whether the light affects static
    (lightmapped) or dynamic geometry, or both (the default). When placing
    multiple bulbs within a lightmapped room, mark them all as
    LightDynamic=true, LightStatic=false, and place a separate Omnilight to add
    bumpiness to the lightmapped surface. Generally, use bulbs for lighting
    dynamic and omnis for lighting static. In some cases, a single Omnilight
    will be enough for both, but remember that Omnilights have no distance
    attenuation.
    - Light ranges: radius for bulb lights, cones for spot lights. There are two
    different properties that you need to adjust separately, one for spatial
    range, the other for graphic attenuation. In general, try to keep them in a
    similar range.
    - Cell range: this is used to tell the light to spatially affect only the
    cell which contains it. It is always a good idea to set this value to True.
    It only really makes sense for dynamic lights (torchlights, mainly) to cast
    light from one room into the next.

    [images: light editor tutorial 5]
    Fig. 5

    Step 4: test dynamic geometry: add a dynamic entity and move it around to
    fine-tune the light color and swee how dynamic geometry fits the lightmapped
    environment. Use it to check shadows as well, if you have enabled any lights
    to cast shadows.

    [images: light editor tutorial 6 and 7]
    Fig. 6 Fig. 7
    
    @section ConjurerGeometryStream Geometry Streams

    This section describes the nebula2 structure named Geometry Stream. Geometry
    streams are the ultimate tool to boost performance and maximize graphics
    sharing in nebula2, so it is quite important to keep these concepts clear.

    Description

    Once authored in 3DS, graphics for a class are divided:

    - By LOD- each level of detail has its own graphics
    - By object- each different 3dsmax obejct is separated from the rest
    - By materials- a different geometry is created for every different
    materials within every object This process works well and gives the artist
    full control on how he wants the geometry and materials to be assigned and,
    most importantly, shared with other classes' graphics for efficient texture
    reuse. The problem is that when they are placed together in a level, each
    different geometry using the same material is drawn separately.

    Geometry instancing partially solves this problem making many instances of
    the same geometry piece share the same draw call. But these instances need
    to be of the exact same class, thus limiting the diversity of geometry that
    can be used in large amounts in a level.

    Streamed rendering

    Several separate geometries can be drawn in a single draw call, by using
    what zombie calls Geometry streams, a technique that mixes batching and
    shader instancing as an efficient way of rendering static geometry.

    [image: streaming in action]

    What is a geometry stream? To simplify it, imagine it as a set of different
    geometries that are merged together on top of each other, sharing the same
    position in space, something like this:

    [image: stream elements stacked]

    Ok, if we separate them to see better what I mean, that's what they'll look:

    [image: stream elements separated]

    In order to effectively share the same render call, all geometries within a
    geometry stream need to share the exact same material. But these houses have
    each their own complete maps, that look like this:

    [image: stream texture before atlas]

    What we do is create a texture atlas: merge all maps together in a single
    texture, and recompute the texture coordinates in each geometry so that they
    sample the new texture instead, like this:

    [image: stream texture after atlas]

    And how can we now make each individual house be rendered in its actual
    position? That's where instancing comes in handy. Each of these houses are
    handled as if they were instances of the same class, but each one is
    actually placed in a different slot of the geometry stream, like this:

    [image: stream slots]

    When each individual geometry needs to be rendered, what happens is that its
    slot in the stream is filled, and in the end, the whole stream is flushed
    (rendered) with amazing performance results, as seen.

    But wait! you may ask: what happens if any of the houses is not visible? Or
    if it is visible at Lod 0 or 1? As in the following situation, where one of
    the entities (houses) in the stream is rendered at LOD 1, and another one is
    invisible:

    Casa_5 Casa_1 Casa_2 Casa_4

    Atlas
    Slot 0: Slot 1: Slot 2: Slot 3:

    [image: stream with hidden slots]

    In this case, we simply fill the remaining slots of the stream, and clear
    the hidden slots, like this:

    [image: stream with hidden slots]

    Which of course means that the actual geometry for the whole stream is sent,
    but only two of the geometry slots are actually transformed &mdash; the
    other ones, they are collapsed into a single vertex, and no pixel is drawn.
    Clever, huh? Ok, no more jokes, time for the...

    Application and drawbacks

    I can hear you thinking: hey, my levels are not only houses, nor single-
    copies of a geometry? There must be more than that! And what if my materials
    are not a simple complete map? And what...? Etc. Answers follow:

    - The first question that arises is: what if one of my streamed houses is
    placed somewhere separate of the other ones? The simple answer: you're
    screwed, don't do it. The long answer: there will be a way to assign
    different streams to the same class geometry, but it is not yet possible.
    - The second question is: what if I want to stream a geometry that has more
    than one material? In that case, you can do the same process, but need to
    assign streams on a per-geometry basis. And you're not always aware of how
    many and which specific geometries are in you exported graphics. Be patient,
    a tool to help you organize this process is coming.
    - And who creates the texture atlases and streams, by the way? Fortunately
    for you, there will be a tool doing the dirty job. What you will need to
    feed it will be the different geometries that you want to group, given that
    they are compatible (meaning they use the same shader, and thus they could
    share an atlas, if created). This will require some effort on the artist
    side to assign materials they can later stream in the editor.

    [image: stream slots]

    - What about trees and other brushes with more than one instance each?
    Geometry streams will support a single source geometry spanning multiple
    slots, but the exact distribution of slots will be up to the user. Again, in
    this case, knowing which graphics will be placed along with which other,
    similar ones, is critical to the success of this technique.
    - And finally, the big question: is this a general enough solution for all
    out performance problems? Or put simpler: is this enough to achieve our most
    desired interactive frame-rate? For short to medium distance ranges (say,
    within some 100 meters from the viewer), definitely yes. In fact, this
    technique will allow reaching the frame-rates seen in other games, but only
    if the source graphics are compatible between them. I've found the main
    reason our engine is so far from the speed of other, similar engines (you
    name you favourite) is that we have way too much diversity: too many
    shaders, too many materials, and that means too many state changes, that are
    used to draw too few geometry sets. There are some restrictions or, at
    least, some rules to be applied to our art-creation process, in order to
    make the art assets friendly to these techniques.
    - And what about long-range graphics, you may ask? Well, streaming will be
    applied to impostor rendering to make them even more efficient. Also, pre-
    computed batches for distant geometry (per terrain block) will take
    advantage of any geometry streams used by their source graphics. For really
    large distances (more or less, farther than sniper range), horizon impostors
    and hierarchical batches will be used, but these techniques are basically
    large data pre-computations.
    Geometry streaming benefits will be more appreciated at a relatively short
    range --not only within sniper range, but within stone-thrower range too.
        
    @subsection ConjurerGeometryStreamEditor Geometry Stream Editor

    This section describes how to define, test and build geometry streams in
    Conjurer. Basically, this exposes a process to tell the editor how to build
    an optimized set of streams. The structures built here are not used at
    runtime, but they are extremely useful for edition and testing. A geometry
    stream is defined as a set of geometries that are to be drawn together. As
    such, it is composed of a list, of which each entry defines:
    - the source class
    - the level in the class
    - the material in that level that uses the edited stream
    - the frequency of the geometry in the stream, meaning the number of copies
    in the stream

    The geometry stream editor allows editing such a list using a standard
    property editor interface. To edit geometry streams, you must set the
    Conjurer Editor Mode: Geometry Stream. This loads the stream library and
    lets you:

    - Load the stream library
    - Create new streams
    - Edit and delete existing streams
    - Test streams to check their effectiveness
    - Build and save optimized streams, and assign them to the original geometry
    Once this editor mode is left, the stream library is unloaded. You'll be
    asked to save it if there are any changes.

    Tutorial

    These are the steps to follow in order to create a Geometry stream:

    - Load one entity of each class you're willing to stream. This is important
    to have a quick way of selecting geometries,
    and seeing the results in place.
    - Select Edit > Streams > New... to create a new stream. Give it a name,
    that must be unique in the library.
    - Once created, you can always edit a stream selecting Edit > Streams 
    Open..., that will list all streams.
    - Either if you're creating it from scratch or you're editing an existing
    one, the same inspector appears:
    - To add geometries to the stream, first set NumGeometries, then fill the
    Class and Level fields for the geometry, and
    then the material identifier, and frequency fields.

    [image: geometry stream editor]

    - To select the specific geometry in the level, you'll have to a) load an
    entity of that class, and b) select it through the material browser, like
    this:

    [image: select geometry elements]

    NOTE: if the material browser appears empty, it is because the resources for
    the class are not loaded. Close the inspector, create an instance of the
    class(es) you're streaming, and open it again to be able to locate materials
    by id. Done! You have successfully created your first stream, with a single
    geometry. Now add as many geometries as you want to the stream.
    - In order to try the stream, use the Edit > Streams > Apply... option, and
    select the stream. This will create an ineditor version of the stream that
    shows how much is gained in draw calls and performance, and how well the
    materials have been merged. You can always revert this operation using Edit
    > Streams > Remove, that will revert any applied streams from their target
    geometries.
    - When you are sure the created/edited stream(s) are good, you can build
    them all into an asset in disk, and effectively assign them to the classes
    that use every geometry. This can be invoked with Edit > Streams > Build
    all. You'll be able to revert this operation later using the Delete option.
    When you build the streams, the stream library is saved as well. To save it
    separately, use Save all.
    - Finally, you can exit the Editor mode: Geometry streams, and you'll be
    asked to save any unsaved streams that you may have modified. (NOT YET
    AVAILABLE)
    
    @section ConjurerLoadingAreas Loading Areas

    Overview

    Adjust light properties

    Move it around Place dynamic entity

    Load Areas in Conjurer are sets of data that are grouped together for
    loading purposes. This means that all graphics, sounds, and other resources
    that are required to represent this area within the editor are to be loaded
    and unloaded together.

    Load Areas are associated with levels, and are sets of cells belonging to
    spaces in this level. Therefore, there are two kinds of load areas:

    - indoor areas: any single indoor space.
    - outdoor areas: any group of terrain cells.

    Thus, editing indoor areas means just selecting an indoor and use it to be
    an area; editing outdoor areas means just selecting several terrain cells
    and assigning them to one or several areas (outdoor areas can be overlapped
    to allow having more than one loaded at the same time, given that there are
    enough available space for that).

    An area encompasses the entities within, and also the resources these
    entities require. Therefore, the tool to define these areas provides the
    user a way to test the size and complexity of that area, meaning the amount
    of memory and resources it takes when it is fully loaded, including system
    memory to hold entities and other structures, geometry, textures, sounds,
    etc.

    Load Areas only define the static setting, spaces and props, but not
    gameplay elements like weapons, vehicles, characters, items, etc. Thus,
    these must be considered separately for the purpose of memory and resource
    usage.

    Area management

    The Edit > Load Areas menu option gives access to the areas defined in the
    current level. The follwing operations can be performed:

    - New outdoor area / New indoor area allow creating a new area, in both
    cases giving it a name
    - Open area allows opening an inspector for the area for setting parameters.
    - Add selection to area allows adding cells to outdoor areas, or assign
    indoor spaces to their areas. NOTE: remember that you can't mix both in the
    same area
    - Remove selection from area allows removing cells from outdoor areas. It
    doesn't apply to indoor areas.
    - Delete area allows removing an area from a level, deleting it from disk as
    well
    - Show area stats computes and show stats for entities and resources in an
    area in a dialog.

    Area loading and unloading

    For optimization purposes, areas are checked only when the active camera
    moves from one cell in the space to the next. At these moments, several
    events are triggered:

    - if the cell belongs to an area that is not loaded, it is loaded
    - if the cell belongs to a new area, any loaded area that is not a neighbor
    of the new one is unloaded: loading only reaches adjacent areas. To keep the
    number of area resources under control
    - distance to neighbor areas is checked: if the neighbor area is nearer than
    a minimum loading distance, it is loaded; if it is further away than some
    maximum unloading distance, it is unloaded.

    The distance check is different for indoor and outdoor areas:

    - between outdoor areas, distance is measured from camera position to the
    center of terrain cells
    - from outdoor to indoor areas, distance is measured from camera position to
    portals leading to the indoor
    - from indoor areas to any other, distance is measured in number of portals
    leading to the neighbor space These distances can be set in both types of
    areas using the inspector for the area (Edit > Loading areas > Open...).

    Outdoor areas and indoor areas check proximity differently: outdoor areas
    check linear distance to the center of the terrain blocks in the area
    against the LoadDistance of the area, whereas indoor areas check the number
    of cells leading to adjacent areas through portals. Both parameters can be
    assigned to areas using their inspectors.
    
    @section ConjurerVariables Variables

    This is where variables that are global to the whole application are edited
    to be saved as global settings to the whole engine. The specific list of
    these variables may grow, but the way to access, edit and save them will be
    always the same.

    Edit global variables

    Go to Edit > Variables > Global variables, an inspector like the following
    is opened:

    [image: global variable editor]

    If any of these variables are updated, you'll be asked if you want to save
    them when exiting conjurer.
    
    @section ConjurerBatches Conjurer Batches

    Batches are static bundles of other, static entities and have two purposes:

    - handle the batch as a single entity in a situation where this saves
    processing power for spatial queries or rendering.
    - storing static entities together as part of a batch allows handling the
    load / unload of static entities through their batches instead of the cells
    containing them, which is helpful to avoid that problem with entities
    falling between to highlevel cells.

    There are two ways of creating batches: manual and automatic. Both are
    explained below.

    Manually creating and editing batches

    Batches are automatically created when a group if entities is made into a
    batch. When the batch has been created, it can be edited as any other
    entity, but it can't be moved, except by moving the entities it contains.
    When all entities inside a batch are destroyed, the batch ceases to exist.

    - To create a batch, use Edit > Batch selection and the selected entities
    will be batched together.
    - If one of the entities in the selection is a batch, the other ones will be
    batched into it. If there is more that one batch selected, the second and
    subsequent ones will be ignored.
    - To delete a batch, delete it just as any other entity. The entities within
    the batch won't be deleted, only unbatched.
    - To remove entities from a batch, select the entity and use Edit > Remove
    from batch

    Automatic batch creation

    Most of the static geometry in a level is to be batched, but it is painful
    for the user to do it by hand. So to automatically batch entities from
    specific classes, entity classes have the BatchStatic bool property.

    The tool Edit > Autobatch free entities will traverse all entities in a
    terrain and for all the entities with that property on, it will batch them
    on a per-cell basis. The tool lets you specify what level of terrain cells
    will be used to create batches, and also how many level of recursive batches
    you want to create. Additional properties of the batches thus created can be
    configured before running the process, as detailed below:

    - MinTestDistance: this value states the distance starting at which batches
    are rendered instead of the individual entities (or sub-batches) they hold.
    - (Re)BuildGraphics: this bool option tells the tool whether to build (or
    rebuild if it was already created) the scene resource (meaning: the bundled
    geometry) of the batch. In all cases, the lowest level of detail will be
    used to create the graphics for the batch.
    
    @section ConjurerUndo Undo

    What can be undone

    Some operations can be undone while others can't. A good rule of thumb to
    use if you want to know if something can be undone or not is: "if it changes
    something in the scene, then it can (usually) be undone, otherwise it cannot
    be undone". For instance, changing a light colour can be undone, while
    changing the intensity of the terrain paintbrush cannot be undone.

    The undo/redo commands can be applied from the Edit/ menu, the respective
    toolbar buttons or the typical Ctrl+Z/Ctrl+Y shortcuts.

    Undo memory usage/limit

    There's an undo memory limit, which can be changed in the preferences
    editor. This memory limit is shown in the status bar, along with the current
    memory usage. When the undo buffer overflows the oldest commands are
    deleted.

    If your computer is getting slow due to high undo memory usage, you can
    clear the undo commands through the Edit/Clear/Clear undo history menu
    option.

    
    @section ConjurerLayers Editor Layers

    Layer manager

    Scene layers can be managed with the layer manager. You can use it to
    select, create, delete, lock and hide layers. Entities in a locked layer
    cannot be edited, while the entities in a hidden layer are not displayed.
    Newly created entities are placed in the selected layer.

    Interface

    The layer manager can be opened from the Edit/Layer manager menu option.

    [image: layer editor]

    Click on a layer to select it. Double click on a layer to modify its name.
    Buttons:
    - New layer: Create a new layer, prompting for a name. The new layer name
    must be unique.
    - Delete layer: Delete the selected layer. Disabled when only one layer is
    defined.
    - Show all: Show all entities in the selected layer.
    - Hide all: Hide all entities in the selected layer.
    - Lock all: Lock all entities in the selected layer.
    - Unlock all: Unlock all entities in the selected layer.
    - picture not found img/wiki_up//lock.bmp: Lock/Unlock all.
    - picture not found img/wiki_up//show.bmp: Show/Hide all.
    - Add all entities in this layer to selection: Select all entities in the
    currently-selected layer.
    - Move selected entities to current layer: Move all currently-selected
    entities to the selected layer.
    - Export all entities in this layer: Export all entities in the selected
    layer. Opens the Export Entity dialog.
    - Import entities to this layer: Import entities from file to the selected
    layer.
    
    @section ConjurerExportEntity Export Entity

    Conjurer Export Entity Dialog

    The Export Entity dialog allows the user to select one or more entities to
    export to file. It can be accessed from the Entity Browser or the Layer
    Manager.

    [image: export entities]

    Each entity in the list can be included in the export or excluded from it by
    clicking on the check box next to it.

    The Select All button selects all entities in the list.

    The Clear All button deselects all entities in the list.

    The Browse button allows the user to select the target export file, which is
    saved with the suffix n2.
    
    @section ConjurerPreferences Preferences

    Overview

    The Preferences dialog allows the user to configure certain Conjurer
    attributes. The configuration values are grouped into panels. The
    Preferences dialog can be opened from the Edit/Preferences menu option.

    General panel

    Any configuration value that cannot be grouped together elsewhere goes on
    this panel:

    - Set the maximum memory used to store undo commands.
    - Set the temporary working path.
    - Set the dot executable path (program to generate FSM previews).
    - Set the default directory for exporting and importing entities.
    - Set the directory where you want your presets stored.
    - Enable the "save current preset option" when exiting Conjurer (you can
    still cancel the save during the exit process). If you don?t usually save
    the preset on exiting, just uncheck Save preset on exit and you won't be
    asked if you want to save it each time.

    [image: preferences]

    Fonts panel

    Set the type for some fonts used in Conjurer:

    - Font used by the script editor.

    [image: font preferences]

    Snap/Grid panel

    Configuration of the grid and snap options:

    - Set the space between grid lines, in world units. Translation snaps to
    these lines when the translation snap option is enabled.
    - Set the frequency of the major grid lines (number of grid lines between
    each - the major grid lines are drawn as thicker lines).
    - Set the colour of the grid lines.
    - Set the colour of the major grid lines.
    - Set the angle increment at which rotation takes place when the rotation
    snap option is enabled.
    - Set the size increment at which scaling takes place when the scaling snap
    option is enabled.

    [image: grid and snap preferences]

    Thumbnails panel

    Set the resolution for some of the thumbnails shown in Conjurer:

    - Thumbnails used by the terrain materials dialog.

    [image: thumbnail preferences]

    
    @section ConjurerViewports Viewports

    Viewports size adjustment

    You can resize the viewports by dragging the handles between them. You can
    also switch between single and multiple views by pressing Alt+W or from the
    View/Single viewport menu option.

    Preset viewports layouts

    The View/Viewports layout menu option displays a dialog that allows you to
    choose from several preset viewport layouts. The selected layout will be
    restored the next time Conjurer starts up (if enabled in the preferences).

    [image: viewport layout]
    
    @section ConjurerDebugOptions Debug Options

    Each debug module instance has its own toggable menu options. These can be
    adjusted from the Debug/Options submenu.

    If you want to persist a debug option configuration, leave the dialog open
    with the appropriate options set when exiting Conjurer.

    [image: debug options]
    
    @section ConjurerLevels Levels

    Overview

    A Level in Conjurer is the complete set of data that makes up a game unit.
    In terms of other games, it's the set of game data that is loaded into
    memory during a game phase. Although the whole level doesn't need to be
    completely loaded into system memory (when using on-demand loading, etc),
    all data contained within it is treated as a unit.

    A level contains a number of entities. These game objects range from the
    terrain and the skybox to every tree, weapon, waypoint and medikit that can
    be found during the level gameplay. The kinds of entities that you can have
    in a level are:

    - Terrain: the outdoor environment where you can place everything else.
    There can be only one terrain per game level.
    - Indoors: indoor environments that can be placed in the terrain and
    connected to it, and to each other, through portals. There can be several
    such spaces.
    - Global entities: these are unique entities that help make up a level but
    aren't directly managed by the game designer. They include the ocean
    surface, skybox, default (standard) light, and others. Conjurer provides
    them for you automatically.
    - Regular entities: everything else. Any other entity in a level is located
    in some space (either outdoor or indoor) and, depending on the particular
    kind of entity, may have a graphical, collision, physical, behavioural, etc.
    component. This general kind of entity can be placed, moved around, copied,
    removed, etc. All of these component pieces can be added to a level, and
    saved, so that they are restored when a level is loaded.

    Level management

    Summoner can only work with one level at a time. By default Summoner is
    started up with a default level (if no other level is given as a command
    argument). The user can do anything he/she wants with this default level
    except save it, so bear in mind that any changes you make to the default
    level will be lost.

    Operations

    The operations to manage levels are found in the Level menu:
    - New level: Create a new level. You will be asked for a new level name,
    which must be unique. When creating a new level, a new blank level will be
    created in the working copy and then loaded in Summoner, replacing the
    current one. Further changes to the level must be saved manually.
    - Open level: Load an existing level into Summoner, replacing the current
    one.
    - Save level: Save the currently-loaded level. This option is disabled if
    working with the default level.
    
    @section ConjurerParticleSystem Particle Systems

    Particle Systems can be viewed from the Particle systems menu option in the
    Edit menu.

    [image: particle editor]

    From here the user can:

    - Create a new particle system
    - Edit an existing system
    - Delete an existing system (N.B. Not yet implemented)
    - View and edit the particle emitters for the selected system

    Creating a New Particle System

    [image: new particle]

    - Class name - enter a class name for the new class
    - Derive from - select a parent class for the new particle system class. The
    default is nemirage
    - Target library - the new particle system class will be created in the
    folder location selected in the tree view. The default location is defined
    in the Preferences dialog, accessible from the main File menu.

    Particle Emitters

    This dialog shows all emitters for the Particle System.

    [image: particle emitters]

    From here the user can:

    - Create a new emitter
    - Edit an existing emitter
    - Delete an emitter
    - Show or hide the selected emitter for all emitters in the scene of the
    given type

    Creating a New Particle Emitter

    [image: new particle emitter]

    - Emitter name - enter a class name for the new emitter
    - Use default texture - if this check box is left checked, the default
    texture will be used when creating the new class. If it is unchecked the
    user must select a custom texture
    - Custom texture - the user can choose a texture file (i.e. a file with
    suffix dds) by pressing the Browse... button: a file picker dialog will be
    shown

    User manual

    Once created, the inspector for the particle system opens so that you can
    edit the newly created particle system. Before editing, place an entity of
    the class just created so that you can see the effect of changes in the
    system definition.

    In order to edit the particle system, read the online manual:

    - http://www.radonlabs.de/ToolkitDocs_HTML/Particle2Howto.html

    Additions to particle systems in Conjurer:

    - The default stretching behavior only admits stretching the particles
    following their moving direction and velocity, and stretching them to the
    start position. To give the user more control on how particles are
    stretched, the StretchUsingCurve property and the ParticleStretchVelocity
    curve have been added. When StretchUsingCurve is true, the stretching of the
    particle follows an envelope curve.
    
    @section ConjurerWindow Window

    The Windows menu has the typical menu options of any MDI application. It
    allows you to cascade windows, or arrange them in columns or in rows. It
    also allows you to move the currently opened windows around and arrange the
    minimized windows.

    Some windows can be opened multiple times, while others only once. For those
    windows that can only be opened once (and aren't modal) a checkmark is used
    at the left of their menu option to show if they're already open.
    
    @section ConjurerHelp Help System

    Summoner has a dynamic help system. This means that the help is context
    sensitive, i.e. the help that will be displayed depends on what has focus
    when it is invoked.

    To access help press F1 at any time. If there is no help available for the
    context nothing will be displayed. If you think that help would be useful
    for the context let the context owner know (of course, it will be a
    programmer ;).
    
    @section ConjurerFSMEditor FSM editor

    All references to script libraries (not to the FSM library) in this document
    are obsolete. Script management has been replaced by the command manager
    (see SWD Nebula Conjurer Command Manager). Note that only the script
    libraries are obsolete: each script type description remains valid.

    FSM editor user guide

    Agents need to adapt to the continuously changing environment in which they
    live. The action an agent should take in any given situation is dictated by
    the FSM attached to that agent. The FSM editor allows the user to edit these
    FSMs and thus define the overall behaviour of the agents.

    The FSM editor is split into 6 components:

    - The FSM editor itself
    - A simple script editor
    - A library of FSMs
    - A library of condition scripts
    - A library of FSM selection scripts
    - A library of action scripts

    The libraries can be accessed from the AI/Finite state machines menu, while
    the FSM editor and the script editor can be accessed from the FSM and script
    libraries respectively.

    Libraries

    When deleting an FSM or user script make absolutely sure that it is no
    longer being used by any other FSM, or that FSM may get corrupted and you
    may lose it (it may even cause Summoner to crash). If you find you have
    deleted one, don't panic. Just create it again (it doesn't matter that it's
    empty) and update the FSM that uses it so you can now safely remove it.

    Using the libraries dialogs you can manage your FSMs and user scripts (just
    look at the the library name to know what is managed by each library). To
    simplify things all dialogs are exact copies with the same operations
    available: create, delete and edit.

    [image: FSM library]

    You can start by creating an FSM in the FSM library and then editing it.
    This will open the FSM editor ready for you to build up the FSM. You can now
    add states and transitions, but bear in mind that until you add user scripts
    in the other libraries you won't be allowed to build an FSM with special
    features like transitions triggered by script, customized actions or even
    hierarchical FSMs.

    FSM editor

    If you want to see FSM previews you should install GraphViz (it can be found
    in [link: www.graphviz.org]) and set the path of the dot.exe file included
    with GraphViz in the preferences dialog (menu Edit/Preferences, section
    General, field dot path). Hopefully this will no longer be necessary in the
    near future.

    The FSM editor is split into two areas:

    - Edit panel: Vertical panel on the left that contains all the controls that
    allows the user to build the FSM. The controls are grouped in different
    subpanels that can be expanded/collapsed by clicking the title button.
    - Preview: Shows a preview of the FSM, using different styles for each state
    and transition type to improve readability.

    [image: FSM editor]

    States panel

    Allows the user to manage the states of the FSM.

    Available controls:

    - States list: Shows all the FSM states and allows the user to select one of
    them to edit or delete. The selected state can be edited in the state type
    and transition panels.
    - New: Create a new state. By default it will be a leaf state.
    - Delete: Delete the currently selected state.
    - Set as initial state: All FSMs need an initial state from which the agent
    will begin its execution. With this button you set the currently selected
    state as the initial one. If an FSM has no initial state the agent cannot
    execute it, so always set an initial state for an FSM. If you see an agent
    standing without doing anything, the chances are that you have forgotten to
    set an initial state for one of its FSMs (an agent may be executing more
    than one FSM at the same time if using hierarchical FSMs).

    State type panel

    There are three types of state:

    - Leaf state: Contains an action to be run by the agent when it enters in
    the state that contains it. When an agent switches to another state, the old
    action being run is replaced by the new one, unless the old action cannot be
    aborted. In this case the new action doesn't start until the old one
    finishes. The state transition always takes place, even if the new action
    needs to wait for the old one to finish. So an agent may have more than one
    action pending to execute, even though it's no longer in the state which
    contained the action.
    - Node state: A node state doesn't contain an action, but a whole child FSM.
    To be more precise, the node state doesn't contain the FSM, but a script
    that tells which child FSM must be executed. This allows the flexibility of
    letting the script either always select the same FSM or select a different
    one each time the agent enters in the node state. It also allows FSMs to be
    used by several agents. Just think of child FSMs as "complex actions", while
    parent FSMs dictate the agent's main behaviour.
    - End state: Indicates the end of a child FSM. When an agent reaches one of
    these states, its FSM is considered finished and the done event thrown
    (again, you can see child FSMs as complex actions, which throw the done
    event as usual actions do when they finish). An FSM can have multiple end
    states if desired, although the only benefit will be a more readable preview
    for the most complex FSMs. The topmost parent FSM can have an end state too,
    but reaching it will leave the agent in a do nothing state since it has no
    parent FSM to continue execution. Parent FSMs don't have end states.

    The state type panel allows the user to set the type of the currently
    selected state and edit it. You set the state type using the choice box.
    Each state type then has its own subpanel:

    - Leaf state panel: Allows the user to choose and edit the action run by the
    agent.
    - Node state panel: Allows the user to choose the FSM selection script used
    to select a child FSM.
    - End state panel: End states have no editable values.

    Transitions panel

    Allows the user to manage and edit all transitions between the FSM states.
    The panel is split into three subpanels:

    - Transitions list
    - Transition type
    - Target states

    Transitions list subpanel

    Allows the user to manage the transitions exiting from the currently
    selected state.

    Available controls:

    - Transitions list: Shows all transitions exiting from the currently
    selected state and allows the user to select one to edit or delete. The
    selected transition can be edited in the transition type and target states
    subpanels.
    - New: Create a new transition. By default it will be an event transition.
    - Delete: Delete the currently selected transition.

    Transition type subpanel

    There are two types of transition:

    - Event transition: Transitions triggered by an event. When the event is
    caught by the agent the transition triggers.
    - Script transition: Transitions triggered by a script. When the script
    evaluates to true the transition triggers. The script is evaluated
    periodically.

    The transition type subpanel allows the user to set the type of the
    currently selected transition and edit its trigger condition.

    You set the transition type using the choice box. Each transition type then
    has its own subpanel to set the trigger condition:

    - Event transition panel: Allows the user to choose the event that triggers
    the transition. Optionally, a filter condition can be chosen too (see the
    section on condition scripts below to learn more about filter conditions).
    - Script transition panel: Allows the user to choose the condition script
    that triggers the transition.

    Target states subpanel

    A transition usually has a single target state. When it is triggered the
    agent moves to this target state. However, it is sometimes desirable for the
    agent to behave less deterministically in order to surprise the player. To
    allow this a transition may have more than one possible target state, with
    each state having a probability of being chosen when the transition
    triggers. Alternatively the transition may have only a single target state,
    but a probability of less than 100% so that it transitions to it only
    sometimes.

    The target states subpanel allows the user to manage and edit the targets of
    the currently selected transition.

    Available controls:

    - Targets list: Shows all targets for the currently selected transition and
    allows the user to select one to edit or delete.
    - New: Add a new target state. By default it will be added with a 100%
    probability of being chosen.
    - Delete: Remove the currently selected target.
    - State: Which state to go for the currently selected target.
    - Probability: Probability of transitioning to the currently selected target
    state when the transition triggers. Symbols used in the FSM preview For each
    state and transition type a different style is used. Styles can be combined.

    [image: fsm preview]

    The labels for the states and transitions give a brief description of the
    contents of the state or transition:

    - A leaf state shows the action to run
    - A node state shows the script used to select the child FSM
    - An end state simply shows that it is an end state since it has no specific
    attribute
    - A transition shows its trigger condition (either the event or the script)
    - A probabilistic transition shows its probability under the trigger
    condition

    State labels are prefixed with a number. Do not confuse it with its
    execution order: the number is just a way to distinguish between two states
    that would otherwise have the same label. It serves no other purpose.

    Scripts

    Scripts extend the capabilities of an FSM by allowing the designer to build
    custom actions and transition conditions, as well as enabling hierarchical
    FSMs. There are three types of script:

    - Action script: Defines an action run by the agent.
    - Condition script: Defines a condition that triggers a transition between
    two states. It can also act as a filter for event transitions.
    - FSM selection script: Selects a child FSM to be executed by the agent.

    Action script

    A script that complements the basic actions that an agent can do. The script
    is called in three situations:
    1) InitAction: Called when the action begins. Do any initialization required
    here.
    2) RunAction: Called periodically while the agent is doing the action.
    Update the agent here. Return true when the action has finished, otherwise
    keep returning false so the agent knows that this action still needs to be
    run some more time.
    3) EndAction: Called when the action has finished. Do any clean up required
    here.

    Condition script

    This script is attached to a transition and represents its condition to
    trigger. It's evaluated periodically when the agent is in the state
    specified in the transition. When this condition evaluates to true (the
    script returns a boolean true) the transition is triggered and the agent may
    change to the target state (it must still pass the probability check if it's
    a transition with less than 100% probability).

    A condition script can also be attached to a transition driven by an event.
    In this case the script acts as a filter for the event that triggers the
    transition, preventing transition for some situations where the event is
    thrown but the transition isn't wanted (the same event can be thrown for two
    different situations, so the condition script is the mechanism that allows
    unwanted situations to be filtered out). The condition script attached to an
    event condition is evaluated only when the event is thrown, triggering the
    transition only when the script evaluates to true.

    FSM selection script

    A script that selects a child FSM. Each node state needs an FSM selection
    script to choose the child FSM that it must expand when the agent enters in
    that state. This is the mechanism used to have hierarchical FSMs, so if you
    don't create FSM selection scripts you can't have hierarchical FSMs. The
    script is run when the agent enters in the node state that have it, and must
    return the child FSM name that the agent must execute.

    Knowing itself and the world

    Since the scripts are shared among agents a script needs to know which agent
    is calling it. To know which agent a script can use the object entity. This
    object has several commands that can be invoked to query or manipulate that
    agent in particular. It can also be used to read/store temporary variables
    for scripted actions related to the same agent. There's also another object,
    named world, which can be used to query the environment where the agent
    lives.

    Executing commands is simple: just write the object and the command to
    execute, separated by a colon. For instance, the following example tells the
    world object to get the entity named box1 and then tells box1 to execute the
    command switchtranslationmotor:

    world:getentity('box1'):switchtranslationmotor()

    Appendices

    - Action list
    - Event list
    - Agent interface command list
    - World interface command list
    
    @section ConjurerFSMAttacher FSM attacher

    Introduction

    Once you have created several FSMs in the FSM editor, it's time to assign
    them to agents so they start behaving in the way you have specified in the
    FSMs.

    An FSM is not assigned to an individual agent instance, but to an agent
    class. This makes it easy to update the behaviour of all agents belonging to
    the same class with a single change. Bear in mind that the attached FSM will
    just be the parent FSM of that particular agent class, nothing prevents you
    from creating hierachical FSMs whose child FSMs are different from agent to
    agent, even though they belong to the same agent class. This can be achieved
    by means of FSM selection scripts that return a different child FSM based on
    some criteria defined by you.

    FSM attacher window

    Associating FSMs to agent classes is done in the FSM attacher window, which
    can be opened through the AI/FSM attacher menu option.

    The window shows a list of all the available agent classes along with their
    respective associated FSM. To attach an FSM to an agent class just select
    the agent class and the FSM in the combo box.

    [image: fsm attach]
    
    @section ConjurerTriggers Triggers

    Area triggers

    SPECIAL CASES:
    - Door triggers

    An area trigger does something in response to an entity entering or leaving
    it. The activation shape of an area trigger can be either a cylinder or a
    prism. By default they're created with an infinite height (represented by a
    0 height), but a finite height can be specified as well. The former is
    usually used for outdoor, while the latter is more useful for indoors.

    Creating and setting area triggers usually involves the following steps:

    1. Create an area trigger in the level

    Use the circular and polygonal trigger creation tools

    [image: circle and polygon trigger]

    To create a circular trigger click and hold where you want the centre of the
    trigger to be and then drag to set the radius. Release the mouse button to
    create the trigger. To create a polygonal trigger click where you want to
    place each polygon vertex. You can hold click and drag to move the vertex
    around before setting it down. To create the trigger press Enter. To abort
    the creation select another edit tool. Important: polygons must be always
    convex. Trigger shapes can be moved around, but not scaled and rotated (they
    always have a base parallel to the XZ plane).

    2. Set the input events that activate the trigger

    The trigger will look only for those area event types that are set as the
    trigger input. Then the trigger will activate when any of these events
    enters or exits the trigger area. To set the input events select the trigger
    and inspect it (either Edit/Selected entities or Edit/Track selected entity
    menu options, see SWD Nebula Conjurer Object tools). In the Input panel you
    define the event types that the trigger perceives.

    [image: trigger input]

    You can also make the trigger activate only once by enabling the TriggerOnce
    property in the Properties panel.

    3. Write the output script

    As in the FSM editor, trigger scripts are created and managed through the
    command manager. The output scripts are placed in the AI/Trigger output
    directory within the command manager. Like an FSM script, the world object
    is available to the trigger script. A trigger script can also know its
    executing trigger (trigger object) and the entity that has caused the
    trigger to execute the script (entity object).

    4. Set the output script

    Finally, in the Output panel you set the output script(s) that you want to
    execute, either for on enter or on exit. You can set more than one output
    script and execute them all or just one at random or even some at random.
    Also, you can make the output execute after a delay. Note that delayed time
    is currently specified in game ticks. This will be changed to use seconds at
    some point in the future.

    [image: trigger output]

    Door Triggers

    How to place an openable door and a door trigger that changes its state
    Place the door (openable doors are currently found in the "negameplaydoor"
    folder of the Grimoire).

    Place a trigger, and open its properties window. For output, choose the
    script to affect the door (For example: Open_gameplay_door).

    In the Commands tab, do the following:

    - Choose class: neareatrigger
    - Choose command: setintvariable
    - Enter "doorId" as string and the door's object ID as integer.
    - Execute.

    Set other trigger settings as desired (don't forget to set perceivable
    events).
    
    @section ConjurerAITestMode AI test mode

    Testing AI

    For testing all the agents and triggers in a level there's a special mode
    that can be switched on and off with the AI toolbar button. Clicking this
    button will start all agents and triggers running. Bear in mind that within
    this mode any edit you do can be dangerous and is not recommended if you
    haven't previously saved the level.

    While in game mode the AI mode is turned on automatically and cannot be
    deactivated until you leave game mode.

    Test settings

    You can control the rate at which the AI updates in the AI test settings
    window. Open it from the AI/AI test settings menu option. The update speed
    value has 3 means depending on its sign:

    - Positive number: speed up the AI update
    - Negative number: slow down the AI update
    - Zero: freeze the AI update.

    [image: AI test settings]

    Debug options

    Often it's useful to know what an agent is really doing internally. To help
    in this there are several behaviour-related debug options than can be
    enabled through the debug options window (the game mode uses the rnsview
    options module):

    - AI - Show agent behavior info: Display the state stack of each agent.
    - AI - Show target for basic actions: An orange line will appear to show
    what the target entity of the agent is (if it has one).
    - AI - Show known entities: Dark grey lines will appear to show those
    entities that an agent currently knows about.
    They fade out progressively while their "memory" is vanishing.

    Hint: if you are having problems reading the text, try freezing the AI
    update at any point you want. A good way is to set the focus on the update
    speed slider and use the cursor keys to quickly adjust the update speed.
    
    @section ConjurerCharacterEditor Character Editor

    Overview

    You can use the character editor to play its animations, adjust some
    animation parameters and attach entities to it. To open the character editor
    select a character in the scene and open the editor from the Edit/Selected
    entities menu option. It looks like the traditional object inspector, but
    with two additional panels for editing the character.

    Animation panel

    A list of all available animations is shown. Select one to make the
    character play it. Below the list there are two additional controls: one
    allows you to modify the fade in time for the currently selected animation,
    and the second allows to play the animation backwards (the latter doesn't
    modify the original animation though, so when you reselect the animation it
    will be played forwards again).

    [image: animations]

    Attachments panel

    A list of all available slots (joints, attachments or whatever you want to
    call them) to which entities may be attached is shown. To attach an entity
    to a slot, select a slot in the list and the entity in the scene that you
    want to attach to it. Then click the attach selected entity button.

    Clicking the detach attached entity will detach the entity attached to the
    currently selected slot, while clicking on select attached entity will
    select the attached entity in the scene.

    [image: attachments]
    
    @section ConjurerSoundEditor Sound editor

    Sound library

    NOTE: Samples used in the sound library cannot also be used as music tracks.
    Open the sound library from the Edit / Sound Library menu entry. The table
    of sounds (the library) is shown.

    [image: sound library]

    The sound library browser is split into three panes:

    - Tree view
    - List
    - Details

    Sound Library Tree View Pane

    Shows the directory structure as defined by the sound files associated with
    the library records. The root node (i.e. the top-level item) shows those
    records with associated sound files in the /export/sounds directory within
    the working copy directory. Records with incorrectly-defined sound files are
    also shown here. Expanding a directory node shows the library records for
    the node in the list.

    Sound Library List Pane

    Shows the key attributes for each library record. The list cannot be edited

    - changes are made by selecting an item or items and using the details
    panel. Each row in the list corresponds to a different sound for the game,
    except in the case of variations. The Sound ID column is a unique string
    identifier for the sound, with rows that share the same identifier being
    variations of the same sound. This means that when a sound event is fired
    with sound event "gunshot", one of the variations will be played at random
    to play. The list panel has four buttons:
    - Play - plays the selected sound or sounds
    - Add - adds a new sound, prompting the user for a Sound ID and sound file
    to associate with it
    - Remove - removes the selected sound or sounds
    - Scan for New Files - checks for sound files in the current directory that
    have not yet been associated with a sound record. If files are found a sound
    record is created automatically for each and added to the library. Further,
    if the sound file is in the /exports/sounds/sources directory a sound source
    will also be created (visible in the Grimoire under nesoundsources)

    Sound Library Details Pane

    Shows the attributes of the selected sound, provided that only one sound is
    selected. The following attributes are shown:

    - Sound Id: The string identifier for the sound as explained above.
    - Resource: The sound file name
    - Min distance (meters): distance from the listener (the camera, or main
    character) from which the sound starts attenuating with distance. If the
    sound source is nearer than this parameter, the sound plays at max volume.
    - Max distance: Distance at wich the sound is completely attenuated.
    - Pitch variation: Relative variation of sound frequency, randomly applied
    at each playback. A value of 0.1 corresponds to +-5% of variation
    - Volume var: Same as Pitch var but for the volume
    - Mobile: Flag indicating that the sound source position can be placed once
    and forgotten, that is, the source position doesn't need to be updated. Use
    it when the source is known to be static or for short sounds that don't last
    long enough for it to be worth bothering to update their position. This
    parameter saves CPU.
    - Max instances: Maximum number of instances of the sound playing at a given
    instant. This parameter saves memory.
    - Streamed: When false, the sound is loaded entirely in memory. When true,
    the sound is loaded progressively as needed while playing. Use only in very
    large sounds, such as long conversations in cutscenes.
    - Priority: Each sound is assigned a priority ranging from 1 up (Priority 0
    is assigned to music). The priority is used when assigning hardware buffers
    to newly played sounds. When a sound is played and there are no free
    hardware buffers to use in the sound card, one of the used ones is selected
    and stopped, for use with the new sound. The selection of the buffer is done
    taking into account priority and distance from the player of all active
    buffers. Note that a higher value means a lower priority.

    If more than one sound is selected changes made in the details panel are
    applied to each of the records selected. Attributes for which this is not
    appropriate (such as Minimum and Maximum Distance) are protected. The user
    can change the file associated with the sound record by pressing the Browse
    button and choosing a different file.

    - Save Library - if there changes outstanding an asterisk is shown in the
    title bar after the title. Press the Save Library
    button to save changes to the sound library.
    - Stop All - stops any sounds that are currently playing
    - Scan All for New Files - does the same as the Scan for New Files button in
    the list pane, but checks all directories
    below /export/sounds. N.B. This process can take several minutes
    - Clear Mute/Solo - sets the Mute and Solo flags to off on all sounds in the
    library
    - Filter by Selection - shows only those sounds related to what is currently
    selected in Summoner
    - Close - closes the browser

    Assigning sounds to entity classes

    Open the Grimoire and right-click the class you want to edit. Select "Open
    inspector". In the pop-up window there will be a panel with the table of
    assignment of sound, if the class you selected has sound component (i.e.
    it's sound-able).

    The table has three columns: the sound event name, material name and sound
    name. The first is the name of the event that makes the sound play on that
    entity. The material is the name of the sound material affecting what sound
    will play, and can be left blank if no material is affecting that kind of
    event. The final column is the sound name (string identifier) and
    corresponds to the first column in the sound library.

    When a sound must be played for some reason in the game, a sound event is
    fired and a search is made for the event name in the list, together with the
    material name if appropiate. If no row matching the 'event', 'material' pair
    is found and 'material' is not blank, then a second search is done with
    material as 'default'. This lets you assign sounds to some materials and let
    the rest of them be assigned to a 'default' one. You can test the sounds if
    an entity is selected by selecting a sound event row and pressing the play
    button. Releasing the button stops the sound. You can define the number of
    times the sound should be repeated here: a value of 0 makes it loop
    indefinitely.

    Loading new sounds automatically

    The 'Refresh sounds' button searches for new sounds in /home/export/sounds
    and adds them to the library. A file naming convention is used to obtain
    some information about sound assignment so less work is needed to set up
    sounds. Don't forget to save the library and any created or modified entity
    class when selecting his option.

    Sound file naming convention

    This convention is used for all sounds under /home/export/sounds except for
    those under /home/export/sounds/sources.

    In this directory you can place sound files with no naming restriction, and
    the 'Refresh sounds' option will not only add them to the library but also
    create a new sound source entity class and assign to it the sound
    automatically.

    For all other directories under /home/export/sounds, the new files are added
    to the library, and those wich meet the naming convention are assigned to an
    entity class or a sound event group, as explained below.

    T_999_X_ClassOrGroup_Event_Material_Variation.extension

    The file naming consists of fields separated by an underscore. If a field is
    to be blank, the underscores are mandatory. Below is an explanation of each
    field.

    T- Type id character. Not used.
    999- Sound designers id. Not used.
    X- Assignment character, can be 'C' or 'G'. C means 'class', and the next
    field is the classname to which its sound table will be added an assignment
    to this sound, with event and material indicated by the next two fields. G
    means 'group' and means that this sound will be added to a group (the name
    of the group is in the next field) Later, when you open the sound table for
    a class, you can press the Import button and, after selecting one of the
    existing groups, you can add all the sounds in the group to the entity class
    you are editing.
    ClassOrGroup- Class or group name as explained in the previous field.
    Event- Event name as explained in the previous field.
    Material- Material name as explained in the previous field. Can be blank
    (but separating underscores are mandatory)
    Variation- Here you can put some number or other string to differentiate
    sound files that are variations of the same sound in the library. Sound
    files that are identical except for the variation string will be part of the
    same sound and will be identified in the game with the file name without the
    variation string. When a sound is played, one of the variations is chosen at
    random.

    Sound events and materials

    The sound events specified in entity classes must coincide with an action
    supported in the game. Specifying the event name is mandatory, but not the
    material. Some of the events, such as gunshots, don't depend on the
    material, but others do, such as footsteps.

    List of currently supported event names:

    trigger:

    Event name / Depends on material / Entity type

    trigger / no / SoundSource Sound area triggers, player entered the area.

    idle / no / Living/Player Entity stops moving

    drivingidle / no / Living/Player Entity stops moving while driving

    walk / yes / Living/Player Entity starts walking

    walkprone / yes / Living/Player Entity starts walking prone

    run / yes / Living/Player Entity starts running

    sprint / yes / Living/Player Entity starts sprinting

    strafe / yes / Living/Player Entity strafes

    jumpstart / yes / Living/Player Entity jumps

    jumpend / yes / Living/Player Entity ends normal jump

    jumpendsuc / yes / Living/Player Entity ends jump succesfully

    jumpendfail / yes / Living/Player Entity ends jump failing

    die / no / Living/Player Entity dies

    drive / no / Living/Player Entity starts driving

    shoot / no / Normally a weapon Entity shoots

    hit / yes / Any dynamic object Entity hits with ground or smaller object

    hitdefense / no / Living/Player Entity is hit while defending itself

    fastreload / no / Normally a weapon Fast reload action start

    fullreload / no / Normally a weapon Full reload action start

    endreload / no / Normally a weapon End of a reload action

    cockreload / no / Normally a weapon Cock reload action

    hideweapon / no / Normally a weapon Hide the weapon
    
    @section ConjurerSoundSources Sound sources

    Placing a sound source

    Sound sources can be placed in the same way as other entities: select the
    sound source class in the Grimoire and place instances using the place tool.

    Enabling a sound source

    Sound sources show the area within which they are heard (to see this, enable
    'Sound sources' in the viewport's debug options). This area matches the
    greatest maximum distance of all the sounds defined in the sound source
    class' event table.

    Although a sound source class may have multiple sound events defined in its
    event table, for sound sources placed directly in the level most of them are
    meaningless. For this kind of sound source you should define a special event
    named trigger and associate with it the sound that you want to be played.
    Internally a sound source acts as an area trigger enabling/disabling the
    sound, so its input and output fields are the same as for an area trigger.
    However, it normally only needs player input, which is activated by default
    for sound sources. This make the sound play when the player is near it.

    [image: sound]

    Testing the sound sources

    showweapon no Normally a weapon Show the weapon

    weaponacc no Normally a weapon Mount an accessory (except silencer)

    silenceron no Normally a weapon Mount silencer

    silenceroff no Normally a weapon Dismount silencer

    switch no Normally a weapon Switch weapon fire mode

    stand yes Living/Player Entity stands up

    ironsight no Living/Player Entity enters ironsight mode

    crouch yes Living/Player Entity crouches down

    prone yes Living/Player Entity prone

    Just push the sound enable button on the toolbar [image: sound] and move
    around the world to hear sounds.
    
    @section ConjurerPresets Presets

    Introduction

    Presets allow some user configuration state to be shared between different
    levels, or even new ones. This state can be updated and saved when working
    on a level. Then all other levels that share the same preset will be opened
    with the same state. It's important to note that presets are saved
    separately from the level, so creating, modifying or deleting them will not
    have any impact on the level data, just in how it will be opened for edit.

    Currently, a preset consist of the values for the stdlight, viewports
    (incluing their layout), and the current set of camera bookmarks.

    Operations

    The following operations can be used to manage your presets: all are
    available from the Levels menu (as a quick guide, a short help text is shown
    in the status bar when the mouse is held over some of these menu options):

    - Save preset as default: Save the current preset state as the default one
    to be used by those levels which don't have an associated preset. This
    operation is the same as saving a preset with the name default.
    - Save preset as: Save the current preset state with the name you specify.
    - Delete preset: Delete the preset you have selected.
    - Assign preset to level: Choose the preset that will be applied to a level
    each time it's opened.

    Don't panic

    The presets system has been tested and used thoroughly, but there are always
    unpredictable situations where something goes wrong. If for some reason a
    level fails to open because of a preset-related error, you can still remedy
    the situation.

    Presets are local to each user and stored separately from the levels in the
    directory that you specify in preferences (by default, in the
    conjurer/presets subdirectory within your "Documents and settings" user
    folder). Since the presets don't contain any vital information, don't worry
    about taking the following recovery measures.

    If you have read as far as here the chances are that you have a problem with
    the presets. Below is a list of what to delete to try to solve the problem,
    starting with the least drastic:

    1. Deleting a preset association to a level: delete the file with the same
    name as the level within the directory
    conjurer/presets/levels.
    2. Deleting a preset: delete the directory with the same name as the preset
    within the directory conjurer/presets/lib.
    3. Delete all: delete the full conjurer/presets directory.
    4. Sorry, the problem is unrelated to the preset system.
    
    @section ConjurerCommandManager Command manager

    Overview

    The command manager allows you to create custom classes and extend existing
    ones with custom commands. There are two types of classes and commands in
    Conjurer: native and custom. The native ones are internal to Conjurer, while
    the custom ones are created by the user. This means that you can create and
    delete custom classes and commands, but not native ones (you can, however,
    extend these with custom commands). Custom commands are implemented as
    script functions and each is stored in a separate file.

    You might use the command manager to add extra functionallity to an entity
    through a custom command or to define some new behavior to be used by
    agents.

    Interface

    The command manager window is split into two parts: the class tree view and
    the commands list. The class tree view actually contains two trees, one
    showing all the native classes (and their inheriting custom classes) and the
    other showing a friendly grouping of all AI-related custom classes.

    The commands list shows all the custom commands that a class exposes (native
    commands aren't shown). A command isn't shown just by its name, but with the
    syntax:

    <output argument types>_<command name>_<input argument types>, where each
    type is represented by a letter (b=bool, f=float, i=int, o=object, s=string,
    v=void).

    [image: command manager]

    To make it is easy to identify each node type in the tree a different symbol
    is used for each:

    - [image: native class]: Native class
    - [image: custom class]: Custom class
    - [image: folder collapsed and expanded]: Folder grouping some related
    classes/subfolders
    - [image: global doc]: Collection of custom global functions not attached to
    any class

    To create a custom class select the folder/parent class you want to create
    it in/inherit from and click on the New button in the classes group (some
    folders cannot contain custom classes: just check if the New button is
    enabled to see which allow this). Classes are created without commands, but
    those created within a folder may have some commands by default (usually
    because they are required for their expected role).

    To create a custom command select the class you want to extend and click on
    the New button in the commands group. This will show a dialog asking you for
    the command prototype: that is, its name and input and output argument
    types. If the command doesn't have any input or output arguments, leave this
    blank and it will take void by default.

    [image: new cmd]

    After creating a command you can edit it by selecting it and clicking on the
    the edit button or by simply double-clicking the command. A script editor
    will appear with the script function that implements the command. You will
    need to set the input argument list as appropiate, as well as returning the
    correct output arguments that you specified when creating the command.

    To make Conjurer aware of changes you have made to a command you should use
    the Scripts/Refresh all scripts menu option.

    Use the Scripts/Clean trash commands menu option occasionally to clean up
    any residual commands that may have been created and not deleted when their
    classes weren't persisted.

    AI custom classes

    AI related classes can be created from the AI tree. This includes classes
    related to FSMs and triggers. See @ref ConjurerFSMEditor and @ref
    ConjurerTriggers to find out more about how they are used.

    These classes will be created automatically with one or more commands. Don't
    delete them since they are needed for the class to be used for the
    respective component. Note that when you create a behaviour action you will
    be requested to specify its input arguments, name and output arguments, as
    well as the first input argument, are fixed and cannot be modified.

    The special Global node isn't implemented yet. In the future it will allow
    the creation of custom global functions accessible from any command. For
    instance, it might include a function to calculate the distance between two
    entities.
    
    @section ConjurerNavigationMesh Navigation mesh

    Introduction

    So that agents can move around they need to be told where they can go and
    where they can't. This navigation space is defined by navigation meshes,
    which define the area where an agent can walk. Agents then use this
    navigation space to look for valid paths to their goals. This means that an
    agent can reach a target point only if there's at least one path which falls
    entirely within the navigation mesh.

    However, there isn't only one navigation mesh: there's one for the whole
    outdoor and one (or more) for each indoor. To allow an agent to get to a
    point located in a navigation mesh other than the one where the agent
    currently is, navigation meshes should be connected. These connection links
    tell the agents about additional navigable space, allowing agents to use
    that space to get to other navigation meshes.

    Navigation mesh generation

    To generate a navigation mesh you use two options found in the AI/Navigation
    mesh submenu: Build outdoor mesh and Build selected indoors meshes.
    Obviously, the former is for generating a navigation mesh for the outdoor
    and the latter for any selected indoor. Beware: this process can take a long
    time, especially for the outdoor (several hours if it is for a large level).

    The navigation mesh generation algorithm uses the information defined in 3DS
    Max about which surfaces make up the ground and which are obstacles to
    navigation (in the case of the outdoor, the slope of the terrain defines
    navigation space boundaries too). You will see the navigation mesh polygons
    as red lines with a small cross in the center, drawn a bit over the walkable
    surface they represent. Some meters below the navigation mesh blue
    rectangles are drawn, which represent the obstacles found and that have made
    a hole in the navigation mesh.

    When generating a navigation mesh any static object will create a hole in
    the final generated navigation mesh so agents follow paths avoiding it. Do
    not confuse static objects with dynamic ones (for instance, boxes that can
    be pushed or the agent itself). Dynamic objects are also avoided but only
    after a path to the goal point has been chosen: they do not affect the
    global path, but are taken into account when making local corrections.

    Bear in mind that navigation meshes aren't regenerated automatically.
    Neither are they transformed if their parent entity is. This means that each
    time you place a static object or move an indoor, the navigation mesh will
    no longer contain the valid navigation space and it must be regenerated. For
    indoors, more than one navigation mesh may be generated. Usually, one for
    each level of the indoor, although some large indoors may have multiple
    navigation meshes in the same level to improve physics performance. These
    are separate navigation meshes, so need to be connected to each other too.
    Navigation mesh generation set up Navigation meshes are generated with
    default parameters, some of which can be modified for each particular
    navigation mesh. Changing these parameters doesn't affect the previously-
    generated navigation meshes - only the new ones. This means that each
    navigation mesh can be generated with a different set of values if desired.

    To set the navigation mesh generation parameters choose the AI/Navigation
    mesh/Mesh generation params menu option. The available parameters are:

    - Minimum obstacle height: This parameter allows you to define which
    obstacles near the floor can be walked over and which can't be. An obstacle
    is only considered as such if it's highest point, relative to the floor's
    height, is above the value defined by this parameter.

    [image: min obstacle height]

    - Character height: The height of the characters that will move in the
    navigation mesh. This parameter allows you to define below which obstacles
    an agent can walk and below which it can't. An obstacle is only considered
    as such if it's lowest point, relative to the floor's height, is below the
    value defined by this parameter.

    [image: character height]

    - Triangle meshes as obstacles: Toggle on/off those obstacles that have been
    exported as physics meshes. It's mainly used to detect errors in an exported
    entity.
    - Minimum hard slope: Applies only to outdoor. Split polygons when the
    terrain slope becomes greater than the value defined by this parameter.
    Currently there isn't any benefit in having these extra polygons, but in the
    future they'll be used to constrain the movement of some agents.
    - Maximum walkable slope: Applies only to outdoor. Easy: over this slope no
    navigation mesh is generated at all.
    - Sea level: Applies only to outdoor. Easy again: below this height no
    generation mesh is generated at all.

    Additionally, you can choose to not generate a navigation mesh for the whole
    outdoor, but instead do so for only a part of it. To do so, just select the
    terrain cells for which you want a navigation mesh to be generated and
    generate the navigation mesh for the outdoor as usual. Better results are
    achieved if the selected cells form a rectangle. For strange shapes some
    artifacts can be generated at the cells boundaries if the final generated
    navigation mesh reaches that boundary.

    Walkable brushes

    For an indoor entity a navigation mesh can be generated just by choosing its
    respective menu option, but you can also generate a navigation mesh for a
    brush if it has been exported with the proper navigation mesh information,
    as an indoor should have been, and then is converted to walkable inside
    Conjurer. To convert a brush into a walkable one, create a new
    newalkablebrush entity class, using for the new class the asset of the
    original brush. That is, in the Grimoire right click on the brush you want
    to make walkable and choose Create class with another asset. In the
    superclass field choose newalkablebrush class. Some brushes will come in
    three parts: static, ramps and stairs. Only the static part must be made
    walkable, the other two don't contain navigation information, just physics
    information. Each part refers to different physics categories and, although
    you can place them individually in the level, it's recommendable to create a
    single superentity containing all three for a later faster usage. The best
    approach is to set the static one as the parent and place the ramps and
    stairs as its children. The person who has exported them has already done
    the work of placing the ramps and stair accurately, so set the relative
    position of the children to 0,0,0. Walkable brushes don't have support for
    multiple floors. If a walkable brush has more than one walkable surface, it
    will be exported with only one floor and you will need to define the other
    walkable space by means of navigation nodes.

    Navigation nodes

    To connect navigation meshes you will need to place a navigation node on
    each side of the navigation mesh at the point you want the agents to be able
    to cross. A navigation link between connected navigation nodes will be
    created, as well as a link from/to the navigation mesh polygons which
    contains each of them. To create navigation nodes choose the menu option
    Tools/Waypoints creation tool or the associated toolbar button (do not
    confuse with the similarly named Waypoint paths creation tool). Then, each
    time you click on Summoner you'll place a new navigation node. If there was
    a previously selected navigation node the new one will be linked with that.
    After placing a navigation node it becomes automatically selected to speed
    up the process of creating a sequence of navigation nodes.

    To see the navigation nodes enable the options Debug/options/viewport0/DEBUG

    - Graphics and Debug/options/editor/Draw waypoint. Navigation nodes are
    drawn as boxes while navigation links are drawn as lines. Link lines start
    either at the navigation node or at the center of the navigation mesh
    polygon the bind. Check the lines' starting point to make sure that they
    bind to the correct navigation mesh (for instance, that they aren't binding
    to a navigation mesh located some meters below, but overlapping if seen from
    top).

    Navigation nodes boxes can have three colors:

    - Green: A navigation node connected to a navigation mesh.
    - Blue: An intermediate navigation node not connected to a navigation mesh
    - Red: An ending navigation node not connected to a navigation mesh Usually
    the correct configuration will be green nodes at the ends of a navigation
    node graph and blue ones in the middle. If this isn't what you get, chances
    are that something is wrong. Review it, move any navigation nodes you need
    to adjust and choose the menu option AI/Navigation mesh/Connect all
    navigation graphs to update the navigation node bindings.
    
    @section ConjurerWaypointTool Waypoint Tool

    Player spawn paths

    Just for the demo, the player spawn has been implemented in a simple way.
    Each level needs, for each player, a waypoint path named in a special way:
    Player0 for the first player, Player1 for the second, and so on. When the
    player starts, it's positioned at the first waypoint in its path. When the
    player dies, it goes to the nearest waypoint in its assigned path.

    In Conjurer, if no path named Player0 exists, the player is positioned at
    the current viewport when entering game mode.
    
    @section ConjurerPreloadManager Preload manager

    Introduction

    Some resources cannot be known to be needed during the game until they're
    requested. In these cases the game will stall for a short moment, but that's
    enough to break the pace of the game. To avoid this, the user should specify
    these resources to be preloaded at the begining of the game.

    Resources that should be specified to be preload:

    - Entity classes that are spawned, except if another instance of the same
    class has been placed and saved with the level in the same area.
    - Sounds not found in a sound source (for instance, impacts of objects).
    Basically, any resource not directly present in the area where it's needed
    should be placed in the preload list. If you see that the game stalls on
    activating a trigger, chances are that the resource the trigger is invoking
    must be preloaded.

    Preload manager

    The resources to be preloaded are specified though the preload manager. It
    can be opened through the menu option Level/Preload manager....

    [image: preload]

    It contains two list for each resource type available to preload:

    - Entity classes. Enter the name of the classes to preload.
    - Sounds. Enter the ids (not the file paths) of the sounds to preload. Check
    the sound library for the sound ids.

    The resource list is per level, so you must specify which resources to
    preload for each level.
    
    @section ConjurerAreaEvents Area events

    What an area event is

    An area event mustn't be confused with something that happens once and then
    goes away (these are only a subgroup of area events as understood by
    Conjurer). An area event may be better seen as a signal emitted for some
    time from somewhere in space.

    Area events may be emitted by entities, but this doesn't necessarily mean
    that that entity is its event source. For instance, a sound event may be
    decoupled from the entity that generated it so that the listening agents
    know the location of the sound, but not the location of the entity source,
    which should not be known unless that location is known by other means (such
    as vision or memory).

    There?s usually a one-to-one relationship with an entity emitting an event,
    but this isn't a limitation and an entity may emit as many events as needed.

    Emission vs Perception

    Entities emit events and agents perceive events. The above statement means
    that agents don't perceive entities, but area events. So if an entity
    doesn't emit any events it cannot be perceived. Usually player and emitted
    events have a one-to-one relationship (player entity emitting the player
    event, squad members emitting the squad member event, etc.) but there are
    some special cases where this isn't the case, so bear in mind this important
    distinction about perception. A simple example of an area event is the
    player event, attached to a player when the player can be perceived by
    vision or touch. Of course, only those agents that have the player event
    activated among its perceivable events will perceive the player when it
    emits the event.

    Setting emitted/perceived events

    Simply use the object inspector for the entities/agents you want to change
    (see @ref ConjurerObjectInspector). Remember that not all entities may emit
    an event, only those created with that functionality (these are gameplay
    entities). What you set on the object inspector is only the initial
    configuration of the entity/agent. It may change at runtime by other means
    (for instance, by a behavior action executed by an FSM).

    Performance issue

    Overuse of events may have a signifcant impact on performance. Use them with
    care and try to minimize their emitted and perceived total number at all
    cost, especially when the change affects many agents.

    Consider asking programmers to create a new event not only when you think
    it's needed for some behaviour you want, but also for a particular situation
    where you think that using a more generic event is an overuse of that event.
    Also consider asking for a means to activate/deactivate events at runtime
    when you only need an agent to emit or perceive an event in a particular
    situation, not during it's whole life.
*/
    
/**
    @page ZombieConjurerHowto Conjurer How To

    - @ref ConjurerHowToVehicle
    - @ref ConjurerHowToSeaFoam
    
    @section ConjurerHowToVehicle How To Set Up a Vehicle Class

    @par Recipe

    - 1 Vehicle chassis brush. It should have primitives collision. This brush
    should have 4 dummy plugs, one for each wheel.
    - 1 Wheel brush for each kind of different type of wheels on the vehicle.
    With a sphere as a collision.

    @par Steps

    1- In conjurer Ctrl+G to bring up the grimore.
    2- Go to the natives section, and right click over the newheel class, create
    a new one with a fancy name.
    3- Do as the 2 step for each different kind of wheels that the vehicle will
    have.
    4- On each of this new wheel classes set "settheresourcefiles" to the brush
    corresponding to the wheel.
    5- Add mass to the wheel. (setmass)
    6- Going back on the natives right click on the class nevehicle and creaty a
    new one.
    7- Click twice over this new nevehicles class.
    8- Fill the vehicle properties, don't forget to set the wheels, where it
    says, FrontRightWheel set one of the new create wheels.
    9- Once all the properties are fill it up, just press ok.
    10- Add mass to the vehicle.

    And you are ready tu put the car in the scene.
    
    @section ConjurerHowToSeaFoam How To Create a Sea Foam

    Export a SeaFoam from 3DS MAX

    Exporting a sea foam is not posible. You need use a trick. You export a mesh
    for a existend class.

    To create a Seafoam see below

    * Export to temporary
    * Replace the mesh gamerns/export/assets/goodClass/meshes/mex_xxx.nvx2 by
    wctmp/export/assets/myTmpClass/meshes/newMesh.nvx2

    The max file

    * Use a unique object.
    * The green chanel of vertex color indicate a delay time. 0 indicate 0% of
    delay and maximun indicate 100% of delay.
    The maximun delay is the cicle time. Cycle time is explained in Sea Foam.
    * Remeber in the material to activate the flag MATERIAL VERTEX COLOR

    - Intro
    - Create a foam
    - Edit a foam
    - Create a splah
    - Edit he splash
    - Synchronize the foam with the splash
    - performance

    INTRO

    The effect is divide in two parts.

    - The foam, is a simple rectangle put on the sea. it has a texure with alpha
    and it has animate the texture coordinates.
    - The splash is a particle system. It is syncronizing with foam. it
    represents the splash when the wave to collide.
    - Export Sea foam. The foam use a fixed shader, it only has a fog. It not
    has a specular lighting , bumpmap, etc... Its only a texture with fog or
    without fog.

    Create a foam

    You need a programmer to create it. One example is entityClass SeaFoam.

    Programers steps:
    - Create class with another asset you select SeaFoam. Put your the new name
    and put put in newclass nemirage
    - Save classes.
    - Copy manualy the asset/SeaFoam to asset/NewName without .svn files
    - Replace in all copied files the SeaFoam by NewName

    Edit a foam

    The material has curve params animation

    - Velocity.x the time of cycle
    - Velocity.y The time of climax, the time when it get the maximun malue
    - Velocity.z The time of end, the time when return to 0
    - Velocity.w if it is greater than 0.5 the curve is smoth.
    - MatAmbient contains the minimun values
    - .x contains u offset
    - .y contains v offset
    - .w contains alpha
    - MatDifuse contains the maximun values.
    - .x contains u offset
    - .y contains v offset
    - .w contains alpha
    - The vertex color has the delay time to start for the mesh.

    The script is in export/asset/ClassName/materials/Mat_XXXXXXX.n2
    To edit it in conjurer, the idea is go to material. 2 ways:

    - first
    - Put a foam in the scene
    - Open the property editor of class
    - double click Graphics/scene node , then it open property editor of scene
    - double click in SurfaceNode
    - Second
    - Open object browser
    - Go to /lib/materials/ClassName
    - double click in SurfaceNode

    To save the edits you need save the classes.

    Create a splah

    - Create a particle system, save classes and exit of conjurer.
    - Copy file from 'export\assets\aDefault_sea_splash\anims\animator.n2 to
    gamerns/export/classname/scene/anims\animator.n2''
    - open the export\assets\ClassName\scene\ClassName.n2 with text editor.
    - and put the next text

    @verbatim
    "nthis:setdependency([wc:export/assets/ClassName/anims/animator.n2]],
    [/sys/servers/dependency/nanimatordependencyserver]], [addanimator]])"
    Example
    -- -----------------------------------------------------------
    -- $parser:nluaserver$ $class:ntransformnode$
    -- -----------------------------------------------------------
    nthis:setdependency([[wc:export/assets/Agua_sync/anims/animator.n2]],
    ,[/sys/servers/dependency/nanimatordependencyserver]], [[addanimator]])
    @endverbatim

    Edit the splash

    The animator contains two params, the are the same for all instance of the
    same class.
    - cycletime, Each time to repeat.
    - offsettime , The delay time to start

    The script is in gamerns/export/classname/scene/anims\animator.n2 To edit in 
    realtime:
    - Open the object browser
    - Go to /usr/deps/addanimator/ClassName

    For save the modifications you need save the classes.
    Synchronize the splash with the foam
    - The cicle Time as the same in the foam and the splash
    - The splash's offsettime depends the splash position and the foam vertex
    color
    - If the foam has 3 meshes with different vertex colors, put 3 splash with 
    the same cycle time but it with different timeoffsets.

    Performance
    - Is a good idea make the static batch for a foam, but the problem is not
    posible to edit the material after make the
    static batch.
    - Not make a static batch for a splash.
*/
    
/**
    @page ZombieConjurerProgrammers

    @section ConjurerLog Log Inspector

    The Log Inspector filters and shows all those logs that Nebula generates
    through the log server. It can be displayed from
    the Debug/Log inspector menu option.

    [image: log inspector]
 
    Options and features

    - Log messages for each log class are shown in different colours to make
    identifying them easier.
    - Log messages for each log class can be enabled/disabled by clicking on the
    appropriate Log Class check box
    - Log messages for each log class can be filtered on log priority by 
    entering a number between 0 and 9 in the appropriate Priority entry field. 
    Log messages with a lower priority are more succint than those with a higher 
    priority.
    - Log messages for each log class can be filtered on log group by pressing 
    the appropriate Edit... log group button. The button will only be enabled 
    for those log classes with specific log groups defined. Pressing the Edit... 
    log group button opens the Log Group Selection Dialog
    - The log inspector can be paused to avoid retrieving new log messages. Note 
    that log messages are still generated: they are not lost and can be viewed 
    later by deselecting the Pause toggle button (unless the log buffer 
    overflows).
    - Log messages shown can be cleared (log messages in the buffer are 
    untouched).
    
    @subsection ConjurerLogGroupSelectionDialog Log Group Selection Dialog

    The Log Group Selection Dialog shows all log groups defined for the given 
    log class. It can be accessed from the Log Inspector.

    [image: log groups]

    Options and features

    - All log groups defined for the given log class are shown
    - Each log group can be activated or deactivated using the appropriate check
    box
    - The Select All button activates all log groups for the log class
    - The Clear All button deactivates all log groups for the log class
    
    @section ConjurerSystemInfo System Info

    The system information dialog simply displays some general information:

    - Paths and assigns of the main directories
    - Memory used and number of each resource type

    The system information dialog can be displayed through the Edit/System info
    menu option.

    [image: system info]
    
    @section ConjurerScriptEditor Script Editor

    The script editor allows the user to edit script files with syntax 
    colouring. There's no limit to the number of script editors that you can 
    have open simultaneously.

    You can use the Run button to quickly run the script you're editing. If the 
    script has been modified you'll be asked to save it before running it, or 
    you can choose not to save it and run the old version stored on disk.

    To create, open and save scripts use the File menu or the buttons on the
    toolbar.
    
    @section ConjurerScriptManager Script Manager

    Introduction

    The script manager allows quick access to the most frequently-used custom 
    scripts and even allows the user to add them to the toolbar. All scripts 
    added to the script manager can be run from the script manager itself, the 
    Scripts/Custom scripts/ submenu and, optionally, from the toolbar or 
    keyboard shortcut. When running a Python script, the script can access the 
    script.custom_data variable to store any desired custom data.

    This data will persist between executions, but only if the script is run 
    from the script manager or from its tool button/menu item (this is not the 
    case when it is run from other sources, such as the script editor).

    Interface

    The script manager can be displayed from the Scripts/Script manager menu 
    option.

    [image: script manager]

    Buttons:
    - Add: Add an existing script file.
    - Remove: Remove the selected script.
    - Modify: Display the script settings dialog for the selected script. The
    same as double-clicking on a script.
    - Up: Move the selected script up in the list.
    - Down: Move the selected script down in the list.
    - Open in editor: Open the selected script in a script editor.
    - Run: Run the selected script.

    Script list:
    - Lists all scripts loaded into the script manager.
    - To show a script into the toolbar check the associated check box.
    - The order in the list is the same order used to show the scripts in the
    toolbar.

    Script settings

    [image: script settings]

    For each script you can adjust the following settings:
    - Description: Name displayed in the script manager list.
    - File: File to be executed when the script is run.
    - Shortcut: Shortcut to quickly run a script. Be careful not to use a 
    shortcut that is already taken.
    - Show in toolbar: Enable this to add a button to the toolbar to run the
    script.
    - Label: Specify whether the button in the toolbar will be an image button 
    or a text button. For an image button you can select one of the preset 
    images or choose one of your own (images must be 16x16). For a text button 
    you can enter the text that will be displayed on the button.
    - Tool tip text: Floating text to be displayed when the mouse is over the
    script button.
    - Status bar text: Text to be displayed in the status bar when the mouse is
    over the script button.
    
    @section ConjurerWatcher Watcher

    Introduction

    The variable and command watcher displays the values of Nebula variables 
    (those inside the /sys/var/ NOH) and custom commands. The values can be set 
    to be refreshed manually or at a user-defined interval.

    The commands must be Python commands (hint: use ';' to separate statements 
    within a single command). The commands (and in fact all the dialog state) 
    will be persisted if you keep the watcher dialog open, but not otherwise.

    Interface

    [image: watcher]
    
    - Filter: Filters those variables which don't contain the filter text (this
    is case sensitive and doesn't allow wildcards).
    - Add command watch: Ask for a command text and add it to the command
    watches.
    - Delete command watch: Delete the selected command.
    - Double click on a command: Edit the command (for some mysterious reason it
    actually seems to need a triple click
    followed by a short pause).
    - Refresh checkbox: Set watcher to refresh all watches periodically.
    - Refresh time: Time interval between consecutive refreshes.
    - Refresh button: Refreshes all watches.
    
    @section ConjurerProfilers Profilers

    Profilers are shown in the screen in a tree mode or a flat mode. The 
    profilers are colored. If the profiler has a gray colour, indicates that it 
    was executed in the last frame. If there is a saved profiler to compare, the 
    green colour indicated a improvement in the time and a red colour indicate a 
    drawback in the time. In tree mode, a parent is drawn in white colour and a 
    child is drawn in a pale green colour.

    CTRL + ALT + P : Show/Hide Profilers
    CTRL + ALT + F : Show Profilers in Flat Mode
    CTRL + ALT + T : Show Profilers in Tree Mode
    CTRL + ALT + S : Save Current Profile State, in order to compare
    CTRL + ALT + Q : Save default File Profile ( "hiprofiler.n2" on executable folder)
    CTRL + ALT + W : Load default File Profile ( "hiprofiler.n2" on executable folder )
    CTRL + ALT + R : Reset Profile State
    CTRL + ALT + 0 : Sort Flat Profiler using name
    CTRL + ALT + 1 : Sort Flat Profiler using first column
    CTRL + ALT + 2 : Sort Flat Profiler using second column
    CTRL + ALT + 3 : Sort Flat Profiler using third column
    CTRL + ALT + 4 : Sort Flat Profiler using forth column
    CTRL + ALT + X : Show Normal Values
    CTRL + ALT + C : Show Inmediate Values
    CTRL + ALT + V : Show Short Term Values
    CTRL + ALT + B : Show Mid Term Values
    CTRL + ALT + N : Show Total Time Variance
    CTRL + ALT + M : Show Minimum and Maximum
    
    @section ConjurerVariableMonitor Variable Monitor

    Overview

    The variable monitor allows to control the InGUI monitor server, which 
    displays the evolution of selected variables in time. The two axes for all 
    graphs are time and variable value, so the horizontal axis is shared, while 
    vertical units can differ from graph to graph.

    Variable monitor dialog

    Operations:
    - Add variable: Adds a graph for the selected variable in the control 
    Variable to monitorize.
    - Current graph stats: Choose the graph for which to show minimum, maximum,
    mean and last values.
    - Global history period: Length of the time axis.
    - Show graphs: Toggle the display of all graphs (but don't stop sampling
    values).
    - Fullscreen: Toggle between normal and fullscreen graph display.

    Operations on a graph:
    - Toggle the graph on/off
    - Change the graph color
    - Set the sampling frequency
    - Set the graph smoothness
    - Remove the graph
    
    [image: variable monitor]
*/
