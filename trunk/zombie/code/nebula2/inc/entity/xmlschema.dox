/**

    @defgroup NebulaXMLSchema Nebula XML Schema
    @ingroup Kernel

    @brief The Nebula XML Schema contains metadata information about script commands.
    
    The Nebula XML Schema file is autogenerated from the documentation entered in the source code for script classes and components. It provides useful information for property editors and other applications. It contains help and metadata about the script commands. The format of the commands follows the doxygen syntax.
    
    All the .h, _cmds.cc, _cmds.cpp files are scanned for comments of this type. The following sections describe the formatting of this comments.
    
    @section CommentFormats Comment formats
    
    @subsection ClassCommentFormats Class Comment Formats
    
    Comment for scripting classes (any nClass in general).

    @verbatim
/**
    @scriptclass <script class name>
    
    @cppclass <cpp class name>
    
    @superclass <cpp parent class name>

    @classinfo <documentation>
*/    
    @endverbatim

    Comment for Component Object classes (derived from nComponentObject). The name given in @component is used to group the properties of the component in the editor. Properties of different components could be grouped together if we want to.

    @verbatim
/**
    @component <name of the component shown in the editor>
    
    @cppclass <cpp class name>
    
    @superclass <cpp parent class name>

    @classinfo <documentation>
*/
    @endverbatim

    Comment for Component Class classes (derived from nComponentClass). The name given in @componentclass is used to group the properties of the component in the editor. Properties of different components could be grouped together if we want to.

    @verbatim
/**
    @componentclass <name of the component shown in the editor>
    
    @cppclass <cpp class name>
    
    @superclass <cpp parent class name>

    @classinfo <documentation>
*/
    @endverbatim
    
    Comment for entity objects (derived from nEntityObject). <br>
    Since the new macros this is depecrated. 
    
    @verbatim    
/**
    @entity <entity name>
    
    @cppclass <cpp class name>
    
    @superclass <cpp parent class name>
    
    @components
        component1
        component2
           ...
    @classinfo <informatcion about the entity>
*/    
    @endverbatim
    
    Comment for entity classes (derived from nEntityCLass). <br>    
    Since the new macros this is depecrated. 
    @verbatim
    
/**
    @entityclass <entity class name>
    
    @cppclass <cpp class name>
    
    @superclass <cpp parent class name>
    
    @components
        component1
        component2
           ...
    @classinfo <informatcion about the entity>
*/    
    @endverbatim                     

    @subsection PropertyCommentFormats Property Comment Format

    Properties form part of the state of an object and they are displayed in the property editor. Properties are normally persisted in the SaveCmds method. A property has associated script command for get and set its values. There are several kinds of properties:
    
    - Single value properties. For example, an integer or a float.    
    - Multiple value properties. A property with multiple values, like a vector3 position (x, y, z values).
    - Array of values properties. A propety with N values, and which we can add / remove / modify values. The values are ordered like in an array. The array can be either of single or multiple values.

    A list of valid types and attributes is shown later in this document.

    Info about each value of the property can be specified (see fieldinfo).
    
    A set of properties can be subgrouped by using the subgroup attribute in the @atttrs trag. Remember the properties of components are already grouped depending on the component where they belong, the @subgroup allows to make further groupings inside this group.

    @verbatim
/**
    @property <property name>

    @format
      type(name;attr1=val1;attr2=val2..) -- fieldinfo
      type(name;attr1=val1;attr2=val2..) -- fieldinfo
      ...
      
    @attrs (attr1=val1;attr2=val2)
    
    @info <documentation>
*/
    @endverbatim

    @subsection CommandCommentFormats Command Comment Format    

    An script command can be of several types:
    
    - getter: command used to obtain a single/multiple value property. And to get one of the values of an array property (the index must be provided to the getter).
    - count: command used to get the number of values of an array property.    
    - setter: set a single / multiple value property. The index must be provided to the setter in case of array properties.
    - begin: command used to begin an array property. The number of elements in the array is specified as a parameter.
    - add: command used to add one of the values of an array property.
    - end: last command when setting an array property.

    @verbatim
/**
    @cmd <command name>

    @cmdtype <getter|[count], setter|[begin,add,end]>

    @property <property name>

    @info <documentation>
*/
    @endverbatim

    @subsection OtherCommandFormat Other Command Format

    Other commands (methods) can be specified as:

    @verbatim
/**
    @cmd <command name>

    @input
      type(name;attr1=val1;attr2=val2..) -- comment
      type(name;attr1=val1;attr2=val2..) -- comment
      ...

    @output
      type(name;attr1=val1;attr2=val2..) -- comment
      type(name;attr1=val1;attr2=val2..) -- comment
      ...

    @info <documentation>
*/
    @endverbatim

    @subsection SignalCommentFormat Signal Comment Format

    Information about signals is specified as:

    @verbatim
/**
    @signal <command name>

    @input
      type(name;attr1=val1;attr2=val2..) -- comment
      type(name;attr1=val1;attr2=val2..) -- comment
      ...

    @output
      type(name;attr1=val1;attr2=val2..) -- comment
      type(name;attr1=val1;attr2=val2..) -- comment
      ...

    @info <documentation>
*/
    @endverbatim

    @section DataTypes Data Types

    Data variable types:
    
 - f: floating point value.
 - i: integer value.
 - b: boolean value (true / false).
 - s: string of chars.
 - o: object pointer.
 - v: no data.
 - l: list is only valid as return type.
 - ff: two floating point value (x,y).
 - fff: three floating point values (x,y,z).
 - ffff: four floating point values (x,y,z,w).
 - q: four floating point values (x,y,z,w).
 
    @section PropertyAttributes Attributes for the whole property
    
 - subgroup: subgroup where to put the whole property.
 - private: if true the field is not shown to designers (by default private is false).
    
    @section FormatPropertyAttributes Attributes for property format

    Attributes that can be specified:

 - min: minimum value for this number (int/float).
 - max: maximum value for this number (int/float).
 - default: default value for this number/string/...
 - step: stepping value for the slider / spin
 - editor: type of the editor to use.
    - slider. Slider bar between min and max (min, max, step required).
    - spin. Spin editor (step required).
    - enum. Combo box with an enumeration of options, only one can be selected.
    - flags. List of T/F options with bitfields.
    - color. Color selector.
    - font. Font selector.
 - subtype: add some information about the type being used 
    - asset: selector of available assets
    - texture: selector of availabe textures
    - shader: selector of shader ?
    - file: selector of file
    - directory: selector of directory    
    - entity object: selector of entity objects (entity object browser). It can be an identifier or an object pointer.
    - entity class: selector of entity classes (grimoire / entity class browser). It can be a string or an object pointer to the entity class.
    - nobject class: selector of entity objects (?).
    - nroot: nroot selector. It can be a string or an object pointer.
 - enums=str1:val1,str2:val2,...,strN:valN. strings shown in the editor for the enum values.
 - flags=str1:val1,str2:val2,...,strN:valN. Values for the flags
 
    @section Comments Some comments and restrictions
    
    @subsection Running About running from command line
    
    For create the xmlschema you must run the update.py from command line with the following options:
    python update.py -build xmlschema target module -nogui workspace
    The meaning of important args are:
    - xmlschema: Indicates that the xmlschema generator will be used.
    - target: Indicates the target name. Type 'all' for all targets.
    - module: Indicates the module name. Type 'all' for all modules.
    Example1: Build the xmlschema for all modules in target nkernel:
    python update.py -build xmlschema nkernel all -nogui conjurer
    Example2: Build xmlschema for nroot module:
    python update.py -build xmlschema nkernel nroot -nogui workspace
    
    @subsection DoxFiles About the dox files
    - Dox files are automatically generated and added to solution when it' s needed. Also it's deleted when it's not needed anymore.
    - When you delete a command from source file, it's also deleted from dox file, but it does not happen with properties that must be deleted manually from dox file. 
    - When you delete all commands and properties of a dox file, this will be deleted in the next xmlschema generation.
    - All dox files have the class definition comment, it's used only for parsing purpouses and it musnt' be deleted. If you want comment the class do it in the header or in the cmds file.
    - If you want use _cmds files for comment, the commented class definition (tags @scriptclass, @component...) must be in the _cmds file. If not the parser will fail.
    - If you comment a command that previously wasn't commented, the generator detect it automatically and ask you if you want delete it from dox file or continue using it.
    - Parsing is not magic, you must review all the commands in dox file manually.
    - Entities are all parsed from tragentitylist.cc and don't generate dox file. If you want add documentation, do it just before the macro definition.
    
    @section Examples Examples
    @subsection Entity Entity ncgrenade
    The xml part for the entity is created autonatically parsing the macro. You don't need to do anything. It generates the entity and the entity class with all their components.
    @subsubsection DoxFile Dox file
    No file generated
    @subsubsection SourceCode Source code
    @verbatim
    /** 
        @classinfo This entity define all the behaviour for a grenade
    */
    nNebulaEntity(
        neGrenade, nEntityObject,
        4,  (   ncGPGrenade, ncPhySimpleObj, ncTransform, ncExplosion),
        0,  (   ),
        neGrenadeClass, nEntityClass,
        3,  (   ncGPGrenadeClass, ncExplosionClass, ncPhysicsObjClass),
        0,  (   )
    );
    @endverbatim
    @subsubsection XMLgen XML generated    
    @verbatim
    <entity cppclass="neGrenade" group="negrenade" superclass="nentityobject">
            <doc>
                 This entity define all the behaviour for a grenade
            </doc>
            <component name="ncGPGrenade"/>
            <component name="ncPhySimpleObj"/>
            <component name="ncTransform"/>
            <component name="ncExplosion"/>
            <commands/>
        </entity>
        <entityclass cppclass="neGrenadeClass" group="negrenadeclass" superclass="nentityclass">
            <doc>
                 This entity define all the behaviour for a grenade
            </doc>
            <component name="ncGPGrenadeClass"/>
            <component name="ncExplosionClass"/>
            <component name="ncPhysicsObjClass"/>
            <commands/>
    </entityclass>
    @endverbatim
    @subsection Component Component ncGPgrenade
    The parser try to generated the dox file if needed. This is done parsing the header and the cmds files. Once time the dox is generated, you must review it and changed all you want.
    @subsubsection DoxFile Dox File
    @verbatim
    //--------------------------------------------------------------------------------
    /**
        @componentclass Gameplay
        @cppclass ncGPGrenadeClass
        @superclass ncGameplayClass
        @classinfo
          No information
    */
    
    //--------------------------------------------------------------------------------
    /**
        @property LaunchPower
        @format
          f(LaunchPower) -- get the launch power of the grenade
        @info
          
          get the launch power of the grenade
    */
    
    //--------------------------------------------------------------------------------
    /**
        @property MaxLifeTime
        @format
          f(MaxLifeTime) -- get the maximum life time of the rockets
        @info
          
          get the maximum life time of the rockets
    */
    
    //--------------------------------------------------------------------------------
    /**
        @cmd SetLaunchPower
        @cmdtype setter
        @property LaunchPower
        @info 
          set the launch power of the grenade
    */
    
    //--------------------------------------------------------------------------------
    /**
        @cmd GetLaunchPower
        @cmdtype getter
        @property LaunchPower
        @info 
          get the launch power of the grenade
    */
    
    //--------------------------------------------------------------------------------
    /**
        @cmd SetMaxLifeTime
        @cmdtype setter
        @property MaxLifeTime
        @info 
          set the maximum life time of the rockets
    */
    
    //--------------------------------------------------------------------------------
    /**
        @cmd GetMaxLifeTime
        @cmdtype getter
        @property MaxLifeTime
        @info 
          get the maximum life time of the rockets
    */
    
    //--------------------------------------------------------------------------------
    @endverbatim
    @subsubsection SourceCode Source code
    See ncgpgrenadeclass.h and ncgpgrenadeclass_cmds.cc<br>
    As you can see, all information is extracted from the header because cmds don't have usefull information.<br>
    @subsubsection XMLgen XML generated
    @verbatim
    <component cppclass="ncGPGrenade" group="Gameplay" superclass="ncGPThrowable">
        <doc>
            No information
        </doc>
        <properties/>
        <commands/>
    </component>
    <componentclass cppclass="ncGPGrenadeClass" group="Gameplay" superclass="ncGameplayClass">
        <doc>
            No information
        </doc>
        <properties>
            <property name="LaunchPower">
                <doc>
                    get the launch power of the grenade
                </doc>
                <getterlist>
                    <getter name="GetLaunchPower" subtype="none">
                        <doc>
                            get the launch power of the grenade
                        </doc>
                    </getter>
                </getterlist>
                <setterlist>
                    <setter name="SetLaunchPower" subtype="none">
                        <doc>
                            set the launch power of the grenade
                        </doc>
                    </setter>
                </setterlist>
                <format>
                    <param name="LaunchPower" type="f">
                        <doc>
                            get the launch power of the grenade
                        </doc>
                    </param>
                </format>
            </property>
            <property name="MaxLifeTime">
                <doc>
                    get the maximum life time of the rockets
                </doc>
                <getterlist>
                    <getter name="GetMaxLifeTime" subtype="none">
                        <doc>
                            get the maximum life time of the rockets
                        </doc>
                    </getter>
                </getterlist>
                <setterlist>
                    <setter name="SetMaxLifeTime" subtype="none">
                        <doc>
                            set the maximum life time of the rockets
                        </doc>
                    </setter>
                </setterlist>
                <format>
                    <param name="MaxLifeTime" type="f">
                        <doc>
                            get the maximum life time of the rockets
                        </doc>
                    </param>
                </format>
            </property>
        </properties>
        <commands/>
    </componentclass>
    @endverbatim
    @subsubsection modifications Modifications
    Now I modify the MaxLifeTime property in the dox file for use integer instead of float and add a spinner editor.    
    @verbatim
    //--------------------------------------------------------------------------------
    /**
        @property MaxLifeTime
        @format
          i(MaxLifeTime;editor=spin) -- get the maximum life time of the rockets edit with a spinner
        @info
          
          get the maximum life time of the rockets
    */
    @endverbatim
    Property regenerated in XML:
    @verbatim
    <format>
        <param name="MaxLifeTime" type="i">
            <doc>
                get the maximum life time of the rockets edit with a spinner
            </doc>
            <attr type="editor" value="spin"/>
        </param>
    </format>
    @endverbatim
    So, all changes in the dox have priority over the code information. This also mean that you must to be carefull with all you put in the dox file. For example, I can add a new param in the dox but this param not exists in the real command. Although this issue can be usefull for testing or debug...



    
            
**/      

